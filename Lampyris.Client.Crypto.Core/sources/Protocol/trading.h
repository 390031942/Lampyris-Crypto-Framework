// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: trading.proto
// Protobuf C++ Version: 5.29.4

#ifndef trading_2eproto_2epb_2eh
#define trading_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_trading_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_trading_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_trading_2eproto;
namespace lampyris {
namespace crypto {
namespace protocol {
namespace trading {
class ConditionTriggerBean;
struct ConditionTriggerBeanDefaultTypeInternal;
extern ConditionTriggerBeanDefaultTypeInternal _ConditionTriggerBean_default_instance_;
class LeverageBean;
struct LeverageBeanDefaultTypeInternal;
extern LeverageBeanDefaultTypeInternal _LeverageBean_default_instance_;
class LeverageBracketBean;
struct LeverageBracketBeanDefaultTypeInternal;
extern LeverageBracketBeanDefaultTypeInternal _LeverageBracketBean_default_instance_;
class OrderBean;
struct OrderBeanDefaultTypeInternal;
extern OrderBeanDefaultTypeInternal _OrderBean_default_instance_;
class OrderStatusBean;
struct OrderStatusBeanDefaultTypeInternal;
extern OrderStatusBeanDefaultTypeInternal _OrderStatusBean_default_instance_;
class PositionBean;
struct PositionBeanDefaultTypeInternal;
extern PositionBeanDefaultTypeInternal _PositionBean_default_instance_;
class ReqCancelOrder;
struct ReqCancelOrderDefaultTypeInternal;
extern ReqCancelOrderDefaultTypeInternal _ReqCancelOrder_default_instance_;
class ReqModifyOrder;
struct ReqModifyOrderDefaultTypeInternal;
extern ReqModifyOrderDefaultTypeInternal _ReqModifyOrder_default_instance_;
class ReqOneKeyClosePosition;
struct ReqOneKeyClosePositionDefaultTypeInternal;
extern ReqOneKeyClosePositionDefaultTypeInternal _ReqOneKeyClosePosition_default_instance_;
class ReqPlaceOrder;
struct ReqPlaceOrderDefaultTypeInternal;
extern ReqPlaceOrderDefaultTypeInternal _ReqPlaceOrder_default_instance_;
class ReqQueryActiveOrders;
struct ReqQueryActiveOrdersDefaultTypeInternal;
extern ReqQueryActiveOrdersDefaultTypeInternal _ReqQueryActiveOrders_default_instance_;
class ReqQueryHistoricalOrders;
struct ReqQueryHistoricalOrdersDefaultTypeInternal;
extern ReqQueryHistoricalOrdersDefaultTypeInternal _ReqQueryHistoricalOrders_default_instance_;
class ReqQueryLeverage;
struct ReqQueryLeverageDefaultTypeInternal;
extern ReqQueryLeverageDefaultTypeInternal _ReqQueryLeverage_default_instance_;
class ReqQueryLeverageBracket;
struct ReqQueryLeverageBracketDefaultTypeInternal;
extern ReqQueryLeverageBracketDefaultTypeInternal _ReqQueryLeverageBracket_default_instance_;
class ReqQueryPositions;
struct ReqQueryPositionsDefaultTypeInternal;
extern ReqQueryPositionsDefaultTypeInternal _ReqQueryPositions_default_instance_;
class ReqSetLeverage;
struct ReqSetLeverageDefaultTypeInternal;
extern ReqSetLeverageDefaultTypeInternal _ReqSetLeverage_default_instance_;
class ResQueryLeverage;
struct ResQueryLeverageDefaultTypeInternal;
extern ResQueryLeverageDefaultTypeInternal _ResQueryLeverage_default_instance_;
class ResQueryLeverageBracket;
struct ResQueryLeverageBracketDefaultTypeInternal;
extern ResQueryLeverageBracketDefaultTypeInternal _ResQueryLeverageBracket_default_instance_;
class ResQueryOrders;
struct ResQueryOrdersDefaultTypeInternal;
extern ResQueryOrdersDefaultTypeInternal _ResQueryOrders_default_instance_;
class ResQueryPositions;
struct ResQueryPositionsDefaultTypeInternal;
extern ResQueryPositionsDefaultTypeInternal _ResQueryPositions_default_instance_;
class SymbolLeverageBracketBean;
struct SymbolLeverageBracketBeanDefaultTypeInternal;
extern SymbolLeverageBracketBeanDefaultTypeInternal _SymbolLeverageBracketBean_default_instance_;
}  // namespace trading
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace lampyris {
namespace crypto {
namespace protocol {
namespace trading {
enum OrderType : int {
  LIMIT = 0,
  MARKET = 1,
  STOP_LOSS = 2,
  TAKE_PROFIT = 3,
  STOP_LOSS_MARKET = 4,
  TAKE_PROFIT_MARKET = 5,
  TRAILING_STOP_MARKET = 6,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderType_IsValid(int value);
extern const uint32_t OrderType_internal_data_[];
constexpr OrderType OrderType_MIN = static_cast<OrderType>(0);
constexpr OrderType OrderType_MAX = static_cast<OrderType>(6);
constexpr int OrderType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
OrderType_descriptor();
template <typename T>
const std::string& OrderType_Name(T value) {
  static_assert(std::is_same<T, OrderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderType_Name().");
  return OrderType_Name(static_cast<OrderType>(value));
}
template <>
inline const std::string& OrderType_Name(OrderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OrderType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool OrderType_Parse(absl::string_view name, OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderType>(
      OrderType_descriptor(), name, value);
}
enum OrderStatus : int {
  NEW = 0,
  PARTIALLY_FILLED = 1,
  FILLED = 2,
  CANCELED = 3,
  REJECTED = 4,
  EXPIRED = 5,
  EXPIRED_IN_MATCH = 6,
  OrderStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderStatus_IsValid(int value);
extern const uint32_t OrderStatus_internal_data_[];
constexpr OrderStatus OrderStatus_MIN = static_cast<OrderStatus>(0);
constexpr OrderStatus OrderStatus_MAX = static_cast<OrderStatus>(6);
constexpr int OrderStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
OrderStatus_descriptor();
template <typename T>
const std::string& OrderStatus_Name(T value) {
  static_assert(std::is_same<T, OrderStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderStatus_Name().");
  return OrderStatus_Name(static_cast<OrderStatus>(value));
}
template <>
inline const std::string& OrderStatus_Name(OrderStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OrderStatus_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool OrderStatus_Parse(absl::string_view name, OrderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatus>(
      OrderStatus_descriptor(), name, value);
}
enum TimeInForceType : int {
  GTC = 0,
  IOC = 1,
  FOK = 2,
  GTX = 3,
  GTD = 4,
  TimeInForceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TimeInForceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TimeInForceType_IsValid(int value);
extern const uint32_t TimeInForceType_internal_data_[];
constexpr TimeInForceType TimeInForceType_MIN = static_cast<TimeInForceType>(0);
constexpr TimeInForceType TimeInForceType_MAX = static_cast<TimeInForceType>(4);
constexpr int TimeInForceType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
TimeInForceType_descriptor();
template <typename T>
const std::string& TimeInForceType_Name(T value) {
  static_assert(std::is_same<T, TimeInForceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimeInForceType_Name().");
  return TimeInForceType_Name(static_cast<TimeInForceType>(value));
}
template <>
inline const std::string& TimeInForceType_Name(TimeInForceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TimeInForceType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TimeInForceType_Parse(absl::string_view name, TimeInForceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForceType>(
      TimeInForceType_descriptor(), name, value);
}
enum OrderSide : int {
  BUY = 0,
  SELL = 1,
  OrderSide_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OrderSide_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OrderSide_IsValid(int value);
extern const uint32_t OrderSide_internal_data_[];
constexpr OrderSide OrderSide_MIN = static_cast<OrderSide>(0);
constexpr OrderSide OrderSide_MAX = static_cast<OrderSide>(1);
constexpr int OrderSide_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
OrderSide_descriptor();
template <typename T>
const std::string& OrderSide_Name(T value) {
  static_assert(std::is_same<T, OrderSide>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderSide_Name().");
  return OrderSide_Name(static_cast<OrderSide>(value));
}
template <>
inline const std::string& OrderSide_Name(OrderSide value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OrderSide_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool OrderSide_Parse(absl::string_view name, OrderSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderSide>(
      OrderSide_descriptor(), name, value);
}
enum PositionSide : int {
  LONG = 0,
  SHORT = 1,
  PositionSide_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PositionSide_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PositionSide_IsValid(int value);
extern const uint32_t PositionSide_internal_data_[];
constexpr PositionSide PositionSide_MIN = static_cast<PositionSide>(0);
constexpr PositionSide PositionSide_MAX = static_cast<PositionSide>(1);
constexpr int PositionSide_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PositionSide_descriptor();
template <typename T>
const std::string& PositionSide_Name(T value) {
  static_assert(std::is_same<T, PositionSide>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PositionSide_Name().");
  return PositionSide_Name(static_cast<PositionSide>(value));
}
template <>
inline const std::string& PositionSide_Name(PositionSide value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PositionSide_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PositionSide_Parse(absl::string_view name, PositionSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionSide>(
      PositionSide_descriptor(), name, value);
}
enum ConditionOrderTriggerType : int {
  PRICE = 0,
  RISE_SPEED = 1,
  INTERVAL = 2,
  ConditionOrderTriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ConditionOrderTriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ConditionOrderTriggerType_IsValid(int value);
extern const uint32_t ConditionOrderTriggerType_internal_data_[];
constexpr ConditionOrderTriggerType ConditionOrderTriggerType_MIN = static_cast<ConditionOrderTriggerType>(0);
constexpr ConditionOrderTriggerType ConditionOrderTriggerType_MAX = static_cast<ConditionOrderTriggerType>(2);
constexpr int ConditionOrderTriggerType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ConditionOrderTriggerType_descriptor();
template <typename T>
const std::string& ConditionOrderTriggerType_Name(T value) {
  static_assert(std::is_same<T, ConditionOrderTriggerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConditionOrderTriggerType_Name().");
  return ConditionOrderTriggerType_Name(static_cast<ConditionOrderTriggerType>(value));
}
template <>
inline const std::string& ConditionOrderTriggerType_Name(ConditionOrderTriggerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ConditionOrderTriggerType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ConditionOrderTriggerType_Parse(absl::string_view name, ConditionOrderTriggerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionOrderTriggerType>(
      ConditionOrderTriggerType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ReqQueryPositions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqQueryPositions) */ {
 public:
  inline ReqQueryPositions() : ReqQueryPositions(nullptr) {}
  ~ReqQueryPositions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqQueryPositions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqQueryPositions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqQueryPositions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqQueryPositions(const ReqQueryPositions& from) : ReqQueryPositions(nullptr, from) {}
  inline ReqQueryPositions(ReqQueryPositions&& from) noexcept
      : ReqQueryPositions(nullptr, std::move(from)) {}
  inline ReqQueryPositions& operator=(const ReqQueryPositions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqQueryPositions& operator=(ReqQueryPositions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqQueryPositions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqQueryPositions* internal_default_instance() {
    return reinterpret_cast<const ReqQueryPositions*>(
        &_ReqQueryPositions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ReqQueryPositions& a, ReqQueryPositions& b) { a.Swap(&b); }
  inline void Swap(ReqQueryPositions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqQueryPositions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqQueryPositions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqQueryPositions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqQueryPositions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqQueryPositions& from) { ReqQueryPositions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqQueryPositions* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqQueryPositions"; }

 protected:
  explicit ReqQueryPositions(::google::protobuf::Arena* arena);
  ReqQueryPositions(::google::protobuf::Arena* arena, const ReqQueryPositions& from);
  ReqQueryPositions(::google::protobuf::Arena* arena, ReqQueryPositions&& from) noexcept
      : ReqQueryPositions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqQueryPositions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqQueryPositions& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqQueryLeverageBracket final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket) */ {
 public:
  inline ReqQueryLeverageBracket() : ReqQueryLeverageBracket(nullptr) {}
  ~ReqQueryLeverageBracket() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqQueryLeverageBracket* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqQueryLeverageBracket));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqQueryLeverageBracket(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqQueryLeverageBracket(const ReqQueryLeverageBracket& from) : ReqQueryLeverageBracket(nullptr, from) {}
  inline ReqQueryLeverageBracket(ReqQueryLeverageBracket&& from) noexcept
      : ReqQueryLeverageBracket(nullptr, std::move(from)) {}
  inline ReqQueryLeverageBracket& operator=(const ReqQueryLeverageBracket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqQueryLeverageBracket& operator=(ReqQueryLeverageBracket&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqQueryLeverageBracket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqQueryLeverageBracket* internal_default_instance() {
    return reinterpret_cast<const ReqQueryLeverageBracket*>(
        &_ReqQueryLeverageBracket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ReqQueryLeverageBracket& a, ReqQueryLeverageBracket& b) { a.Swap(&b); }
  inline void Swap(ReqQueryLeverageBracket* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqQueryLeverageBracket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqQueryLeverageBracket* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqQueryLeverageBracket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqQueryLeverageBracket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqQueryLeverageBracket& from) { ReqQueryLeverageBracket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqQueryLeverageBracket* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqQueryLeverageBracket"; }

 protected:
  explicit ReqQueryLeverageBracket(::google::protobuf::Arena* arena);
  ReqQueryLeverageBracket(::google::protobuf::Arena* arena, const ReqQueryLeverageBracket& from);
  ReqQueryLeverageBracket(::google::protobuf::Arena* arena, ReqQueryLeverageBracket&& from) noexcept
      : ReqQueryLeverageBracket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqQueryLeverageBracket& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqQueryLeverage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqQueryLeverage) */ {
 public:
  inline ReqQueryLeverage() : ReqQueryLeverage(nullptr) {}
  ~ReqQueryLeverage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqQueryLeverage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqQueryLeverage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqQueryLeverage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqQueryLeverage(const ReqQueryLeverage& from) : ReqQueryLeverage(nullptr, from) {}
  inline ReqQueryLeverage(ReqQueryLeverage&& from) noexcept
      : ReqQueryLeverage(nullptr, std::move(from)) {}
  inline ReqQueryLeverage& operator=(const ReqQueryLeverage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqQueryLeverage& operator=(ReqQueryLeverage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqQueryLeverage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqQueryLeverage* internal_default_instance() {
    return reinterpret_cast<const ReqQueryLeverage*>(
        &_ReqQueryLeverage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReqQueryLeverage& a, ReqQueryLeverage& b) { a.Swap(&b); }
  inline void Swap(ReqQueryLeverage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqQueryLeverage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqQueryLeverage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqQueryLeverage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqQueryLeverage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqQueryLeverage& from) { ReqQueryLeverage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqQueryLeverage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqQueryLeverage"; }

 protected:
  explicit ReqQueryLeverage(::google::protobuf::Arena* arena);
  ReqQueryLeverage(::google::protobuf::Arena* arena, const ReqQueryLeverage& from);
  ReqQueryLeverage(::google::protobuf::Arena* arena, ReqQueryLeverage&& from) noexcept
      : ReqQueryLeverage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqQueryLeverage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqQueryLeverage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqQueryHistoricalOrders final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders) */ {
 public:
  inline ReqQueryHistoricalOrders() : ReqQueryHistoricalOrders(nullptr) {}
  ~ReqQueryHistoricalOrders() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqQueryHistoricalOrders* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqQueryHistoricalOrders));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqQueryHistoricalOrders(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqQueryHistoricalOrders(const ReqQueryHistoricalOrders& from) : ReqQueryHistoricalOrders(nullptr, from) {}
  inline ReqQueryHistoricalOrders(ReqQueryHistoricalOrders&& from) noexcept
      : ReqQueryHistoricalOrders(nullptr, std::move(from)) {}
  inline ReqQueryHistoricalOrders& operator=(const ReqQueryHistoricalOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqQueryHistoricalOrders& operator=(ReqQueryHistoricalOrders&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqQueryHistoricalOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqQueryHistoricalOrders* internal_default_instance() {
    return reinterpret_cast<const ReqQueryHistoricalOrders*>(
        &_ReqQueryHistoricalOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ReqQueryHistoricalOrders& a, ReqQueryHistoricalOrders& b) { a.Swap(&b); }
  inline void Swap(ReqQueryHistoricalOrders* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqQueryHistoricalOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqQueryHistoricalOrders* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqQueryHistoricalOrders>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqQueryHistoricalOrders& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqQueryHistoricalOrders& from) { ReqQueryHistoricalOrders::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqQueryHistoricalOrders* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders"; }

 protected:
  explicit ReqQueryHistoricalOrders(::google::protobuf::Arena* arena);
  ReqQueryHistoricalOrders(::google::protobuf::Arena* arena, const ReqQueryHistoricalOrders& from);
  ReqQueryHistoricalOrders(::google::protobuf::Arena* arena, ReqQueryHistoricalOrders&& from) noexcept
      : ReqQueryHistoricalOrders(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kBeginTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // int64 beginTime = 2;
  void clear_begintime() ;
  ::int64_t begintime() const;
  void set_begintime(::int64_t value);

  private:
  ::int64_t _internal_begintime() const;
  void _internal_set_begintime(::int64_t value);

  public:
  // int64 endTime = 3;
  void clear_endtime() ;
  ::int64_t endtime() const;
  void set_endtime(::int64_t value);

  private:
  ::int64_t _internal_endtime() const;
  void _internal_set_endtime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      72, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqQueryHistoricalOrders& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::int64_t begintime_;
    ::int64_t endtime_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqQueryActiveOrders final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqQueryActiveOrders) */ {
 public:
  inline ReqQueryActiveOrders() : ReqQueryActiveOrders(nullptr) {}
  ~ReqQueryActiveOrders() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqQueryActiveOrders* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqQueryActiveOrders));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqQueryActiveOrders(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqQueryActiveOrders(const ReqQueryActiveOrders& from) : ReqQueryActiveOrders(nullptr, from) {}
  inline ReqQueryActiveOrders(ReqQueryActiveOrders&& from) noexcept
      : ReqQueryActiveOrders(nullptr, std::move(from)) {}
  inline ReqQueryActiveOrders& operator=(const ReqQueryActiveOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqQueryActiveOrders& operator=(ReqQueryActiveOrders&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqQueryActiveOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqQueryActiveOrders* internal_default_instance() {
    return reinterpret_cast<const ReqQueryActiveOrders*>(
        &_ReqQueryActiveOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ReqQueryActiveOrders& a, ReqQueryActiveOrders& b) { a.Swap(&b); }
  inline void Swap(ReqQueryActiveOrders* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqQueryActiveOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqQueryActiveOrders* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqQueryActiveOrders>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqQueryActiveOrders& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqQueryActiveOrders& from) { ReqQueryActiveOrders::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqQueryActiveOrders* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqQueryActiveOrders"; }

 protected:
  explicit ReqQueryActiveOrders(::google::protobuf::Arena* arena);
  ReqQueryActiveOrders(::google::protobuf::Arena* arena, const ReqQueryActiveOrders& from);
  ReqQueryActiveOrders(::google::protobuf::Arena* arena, ReqQueryActiveOrders&& from) noexcept
      : ReqQueryActiveOrders(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqQueryActiveOrders)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      68, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqQueryActiveOrders& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqOneKeyClosePosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition) */ {
 public:
  inline ReqOneKeyClosePosition() : ReqOneKeyClosePosition(nullptr) {}
  ~ReqOneKeyClosePosition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqOneKeyClosePosition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqOneKeyClosePosition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqOneKeyClosePosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqOneKeyClosePosition(const ReqOneKeyClosePosition& from) : ReqOneKeyClosePosition(nullptr, from) {}
  inline ReqOneKeyClosePosition(ReqOneKeyClosePosition&& from) noexcept
      : ReqOneKeyClosePosition(nullptr, std::move(from)) {}
  inline ReqOneKeyClosePosition& operator=(const ReqOneKeyClosePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqOneKeyClosePosition& operator=(ReqOneKeyClosePosition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqOneKeyClosePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqOneKeyClosePosition* internal_default_instance() {
    return reinterpret_cast<const ReqOneKeyClosePosition*>(
        &_ReqOneKeyClosePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ReqOneKeyClosePosition& a, ReqOneKeyClosePosition& b) { a.Swap(&b); }
  inline void Swap(ReqOneKeyClosePosition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqOneKeyClosePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqOneKeyClosePosition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqOneKeyClosePosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqOneKeyClosePosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqOneKeyClosePosition& from) { ReqOneKeyClosePosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqOneKeyClosePosition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqOneKeyClosePosition"; }

 protected:
  explicit ReqOneKeyClosePosition(::google::protobuf::Arena* arena);
  ReqOneKeyClosePosition(::google::protobuf::Arena* arena, const ReqOneKeyClosePosition& from);
  ReqOneKeyClosePosition(::google::protobuf::Arena* arena, ReqOneKeyClosePosition&& from) noexcept
      : ReqOneKeyClosePosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolsFieldNumber = 1,
  };
  // repeated string symbols = 1;
  int symbols_size() const;
  private:
  int _internal_symbols_size() const;

  public:
  void clear_symbols() ;
  const std::string& symbols(int index) const;
  std::string* mutable_symbols(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbols(int index, Arg_&& value, Args_... args);
  std::string* add_symbols();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_symbols(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& symbols() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_symbols();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_symbols() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_symbols();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqOneKeyClosePosition& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> symbols_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqCancelOrder final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqCancelOrder) */ {
 public:
  inline ReqCancelOrder() : ReqCancelOrder(nullptr) {}
  ~ReqCancelOrder() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqCancelOrder* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqCancelOrder));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqCancelOrder(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqCancelOrder(const ReqCancelOrder& from) : ReqCancelOrder(nullptr, from) {}
  inline ReqCancelOrder(ReqCancelOrder&& from) noexcept
      : ReqCancelOrder(nullptr, std::move(from)) {}
  inline ReqCancelOrder& operator=(const ReqCancelOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqCancelOrder& operator=(ReqCancelOrder&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqCancelOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqCancelOrder* internal_default_instance() {
    return reinterpret_cast<const ReqCancelOrder*>(
        &_ReqCancelOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ReqCancelOrder& a, ReqCancelOrder& b) { a.Swap(&b); }
  inline void Swap(ReqCancelOrder* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqCancelOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqCancelOrder* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqCancelOrder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqCancelOrder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqCancelOrder& from) { ReqCancelOrder::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqCancelOrder* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqCancelOrder"; }

 protected:
  explicit ReqCancelOrder(::google::protobuf::Arena* arena);
  ReqCancelOrder(::google::protobuf::Arena* arena, const ReqCancelOrder& from);
  ReqCancelOrder(::google::protobuf::Arena* arena, ReqCancelOrder&& from) noexcept
      : ReqCancelOrder(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
  };
  // int64 orderId = 1;
  void clear_orderid() ;
  ::int64_t orderid() const;
  void set_orderid(::int64_t value);

  private:
  ::int64_t _internal_orderid() const;
  void _internal_set_orderid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqCancelOrder)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqCancelOrder& from_msg);
    ::int64_t orderid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class PositionBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.PositionBean) */ {
 public:
  inline PositionBean() : PositionBean(nullptr) {}
  ~PositionBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline PositionBean(const PositionBean& from) : PositionBean(nullptr, from) {}
  inline PositionBean(PositionBean&& from) noexcept
      : PositionBean(nullptr, std::move(from)) {}
  inline PositionBean& operator=(const PositionBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionBean& operator=(PositionBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionBean* internal_default_instance() {
    return reinterpret_cast<const PositionBean*>(
        &_PositionBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PositionBean& a, PositionBean& b) { a.Swap(&b); }
  inline void Swap(PositionBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionBean& from) { PositionBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.PositionBean"; }

 protected:
  explicit PositionBean(::google::protobuf::Arena* arena);
  PositionBean(::google::protobuf::Arena* arena, const PositionBean& from);
  PositionBean(::google::protobuf::Arena* arena, PositionBean&& from) noexcept
      : PositionBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kQuantityFieldNumber = 3,
    kUnrealizedPnLFieldNumber = 4,
    kRealizedPnLFieldNumber = 5,
    kInitialMarginFieldNumber = 6,
    kPositionSideFieldNumber = 2,
    kAutoDeleveragingLevelFieldNumber = 10,
    kMaintenanceMarginFieldNumber = 7,
    kCostPriceFieldNumber = 8,
    kMarkPriceFieldNumber = 9,
    kLiquidationPriceFieldNumber = 11,
    kUpdateTimeFieldNumber = 12,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // double quantity = 3;
  void clear_quantity() ;
  double quantity() const;
  void set_quantity(double value);

  private:
  double _internal_quantity() const;
  void _internal_set_quantity(double value);

  public:
  // double unrealizedPnL = 4;
  void clear_unrealizedpnl() ;
  double unrealizedpnl() const;
  void set_unrealizedpnl(double value);

  private:
  double _internal_unrealizedpnl() const;
  void _internal_set_unrealizedpnl(double value);

  public:
  // double realizedPnL = 5;
  void clear_realizedpnl() ;
  double realizedpnl() const;
  void set_realizedpnl(double value);

  private:
  double _internal_realizedpnl() const;
  void _internal_set_realizedpnl(double value);

  public:
  // double initialMargin = 6;
  void clear_initialmargin() ;
  double initialmargin() const;
  void set_initialmargin(double value);

  private:
  double _internal_initialmargin() const;
  void _internal_set_initialmargin(double value);

  public:
  // .lampyris.crypto.protocol.trading.PositionSide positionSide = 2;
  void clear_positionside() ;
  ::lampyris::crypto::protocol::trading::PositionSide positionside() const;
  void set_positionside(::lampyris::crypto::protocol::trading::PositionSide value);

  private:
  ::lampyris::crypto::protocol::trading::PositionSide _internal_positionside() const;
  void _internal_set_positionside(::lampyris::crypto::protocol::trading::PositionSide value);

  public:
  // int32 autoDeleveragingLevel = 10;
  void clear_autodeleveraginglevel() ;
  ::int32_t autodeleveraginglevel() const;
  void set_autodeleveraginglevel(::int32_t value);

  private:
  ::int32_t _internal_autodeleveraginglevel() const;
  void _internal_set_autodeleveraginglevel(::int32_t value);

  public:
  // double maintenanceMargin = 7;
  void clear_maintenancemargin() ;
  double maintenancemargin() const;
  void set_maintenancemargin(double value);

  private:
  double _internal_maintenancemargin() const;
  void _internal_set_maintenancemargin(double value);

  public:
  // double costPrice = 8;
  void clear_costprice() ;
  double costprice() const;
  void set_costprice(double value);

  private:
  double _internal_costprice() const;
  void _internal_set_costprice(double value);

  public:
  // double markPrice = 9;
  void clear_markprice() ;
  double markprice() const;
  void set_markprice(double value);

  private:
  double _internal_markprice() const;
  void _internal_set_markprice(double value);

  public:
  // double liquidationPrice = 11;
  void clear_liquidationprice() ;
  double liquidationprice() const;
  void set_liquidationprice(double value);

  private:
  double _internal_liquidationprice() const;
  void _internal_set_liquidationprice(double value);

  public:
  // int64 updateTime = 12;
  void clear_updatetime() ;
  ::int64_t updatetime() const;
  void set_updatetime(::int64_t value);

  private:
  ::int64_t _internal_updatetime() const;
  void _internal_set_updatetime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.PositionBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      68, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PositionBean& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    double quantity_;
    double unrealizedpnl_;
    double realizedpnl_;
    double initialmargin_;
    int positionside_;
    ::int32_t autodeleveraginglevel_;
    double maintenancemargin_;
    double costprice_;
    double markprice_;
    double liquidationprice_;
    ::int64_t updatetime_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class LeverageBracketBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.LeverageBracketBean) */ {
 public:
  inline LeverageBracketBean() : LeverageBracketBean(nullptr) {}
  ~LeverageBracketBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LeverageBracketBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LeverageBracketBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeverageBracketBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline LeverageBracketBean(const LeverageBracketBean& from) : LeverageBracketBean(nullptr, from) {}
  inline LeverageBracketBean(LeverageBracketBean&& from) noexcept
      : LeverageBracketBean(nullptr, std::move(from)) {}
  inline LeverageBracketBean& operator=(const LeverageBracketBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeverageBracketBean& operator=(LeverageBracketBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeverageBracketBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeverageBracketBean* internal_default_instance() {
    return reinterpret_cast<const LeverageBracketBean*>(
        &_LeverageBracketBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(LeverageBracketBean& a, LeverageBracketBean& b) { a.Swap(&b); }
  inline void Swap(LeverageBracketBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeverageBracketBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeverageBracketBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LeverageBracketBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeverageBracketBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeverageBracketBean& from) { LeverageBracketBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LeverageBracketBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.LeverageBracketBean"; }

 protected:
  explicit LeverageBracketBean(::google::protobuf::Arena* arena);
  LeverageBracketBean(::google::protobuf::Arena* arena, const LeverageBracketBean& from);
  LeverageBracketBean(::google::protobuf::Arena* arena, LeverageBracketBean&& from) noexcept
      : LeverageBracketBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNotionalCapFieldNumber = 2,
    kNotionalFloorFieldNumber = 3,
    kLeverageFieldNumber = 1,
  };
  // double notionalCap = 2;
  void clear_notionalcap() ;
  double notionalcap() const;
  void set_notionalcap(double value);

  private:
  double _internal_notionalcap() const;
  void _internal_set_notionalcap(double value);

  public:
  // double notionalFloor = 3;
  void clear_notionalfloor() ;
  double notionalfloor() const;
  void set_notionalfloor(double value);

  private:
  double _internal_notionalfloor() const;
  void _internal_set_notionalfloor(double value);

  public:
  // int32 leverage = 1;
  void clear_leverage() ;
  ::int32_t leverage() const;
  void set_leverage(::int32_t value);

  private:
  ::int32_t _internal_leverage() const;
  void _internal_set_leverage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.LeverageBracketBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LeverageBracketBean& from_msg);
    double notionalcap_;
    double notionalfloor_;
    ::int32_t leverage_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class LeverageBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.LeverageBean) */ {
 public:
  inline LeverageBean() : LeverageBean(nullptr) {}
  ~LeverageBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LeverageBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LeverageBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeverageBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline LeverageBean(const LeverageBean& from) : LeverageBean(nullptr, from) {}
  inline LeverageBean(LeverageBean&& from) noexcept
      : LeverageBean(nullptr, std::move(from)) {}
  inline LeverageBean& operator=(const LeverageBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeverageBean& operator=(LeverageBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeverageBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeverageBean* internal_default_instance() {
    return reinterpret_cast<const LeverageBean*>(
        &_LeverageBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(LeverageBean& a, LeverageBean& b) { a.Swap(&b); }
  inline void Swap(LeverageBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeverageBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeverageBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LeverageBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeverageBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeverageBean& from) { LeverageBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LeverageBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.LeverageBean"; }

 protected:
  explicit LeverageBean(::google::protobuf::Arena* arena);
  LeverageBean(::google::protobuf::Arena* arena, const LeverageBean& from);
  LeverageBean(::google::protobuf::Arena* arena, LeverageBean&& from) noexcept
      : LeverageBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kMaxNotionalFieldNumber = 3,
    kLeverageFieldNumber = 2,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // double maxNotional = 3;
  void clear_maxnotional() ;
  double maxnotional() const;
  void set_maxnotional(double value);

  private:
  double _internal_maxnotional() const;
  void _internal_set_maxnotional(double value);

  public:
  // int32 leverage = 2;
  void clear_leverage() ;
  ::int32_t leverage() const;
  void set_leverage(::int32_t value);

  private:
  ::int32_t _internal_leverage() const;
  void _internal_set_leverage(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.LeverageBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LeverageBean& from_msg);
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    double maxnotional_;
    ::int32_t leverage_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ConditionTriggerBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ConditionTriggerBean) */ {
 public:
  inline ConditionTriggerBean() : ConditionTriggerBean(nullptr) {}
  ~ConditionTriggerBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConditionTriggerBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConditionTriggerBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConditionTriggerBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConditionTriggerBean(const ConditionTriggerBean& from) : ConditionTriggerBean(nullptr, from) {}
  inline ConditionTriggerBean(ConditionTriggerBean&& from) noexcept
      : ConditionTriggerBean(nullptr, std::move(from)) {}
  inline ConditionTriggerBean& operator=(const ConditionTriggerBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionTriggerBean& operator=(ConditionTriggerBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionTriggerBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionTriggerBean* internal_default_instance() {
    return reinterpret_cast<const ConditionTriggerBean*>(
        &_ConditionTriggerBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ConditionTriggerBean& a, ConditionTriggerBean& b) { a.Swap(&b); }
  inline void Swap(ConditionTriggerBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionTriggerBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionTriggerBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConditionTriggerBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConditionTriggerBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConditionTriggerBean& from) { ConditionTriggerBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConditionTriggerBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ConditionTriggerBean"; }

 protected:
  explicit ConditionTriggerBean(::google::protobuf::Arena* arena);
  ConditionTriggerBean(::google::protobuf::Arena* arena, const ConditionTriggerBean& from);
  ConditionTriggerBean(::google::protobuf::Arena* arena, ConditionTriggerBean&& from) noexcept
      : ConditionTriggerBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .lampyris.crypto.protocol.trading.ConditionOrderTriggerType type = 1;
  void clear_type() ;
  ::lampyris::crypto::protocol::trading::ConditionOrderTriggerType type() const;
  void set_type(::lampyris::crypto::protocol::trading::ConditionOrderTriggerType value);

  private:
  ::lampyris::crypto::protocol::trading::ConditionOrderTriggerType _internal_type() const;
  void _internal_set_type(::lampyris::crypto::protocol::trading::ConditionOrderTriggerType value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ConditionTriggerBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConditionTriggerBean& from_msg);
    ::google::protobuf::internal::ArenaStringPtr value_;
    int type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class SymbolLeverageBracketBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean) */ {
 public:
  inline SymbolLeverageBracketBean() : SymbolLeverageBracketBean(nullptr) {}
  ~SymbolLeverageBracketBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SymbolLeverageBracketBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SymbolLeverageBracketBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SymbolLeverageBracketBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline SymbolLeverageBracketBean(const SymbolLeverageBracketBean& from) : SymbolLeverageBracketBean(nullptr, from) {}
  inline SymbolLeverageBracketBean(SymbolLeverageBracketBean&& from) noexcept
      : SymbolLeverageBracketBean(nullptr, std::move(from)) {}
  inline SymbolLeverageBracketBean& operator=(const SymbolLeverageBracketBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolLeverageBracketBean& operator=(SymbolLeverageBracketBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolLeverageBracketBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolLeverageBracketBean* internal_default_instance() {
    return reinterpret_cast<const SymbolLeverageBracketBean*>(
        &_SymbolLeverageBracketBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SymbolLeverageBracketBean& a, SymbolLeverageBracketBean& b) { a.Swap(&b); }
  inline void Swap(SymbolLeverageBracketBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolLeverageBracketBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolLeverageBracketBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SymbolLeverageBracketBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SymbolLeverageBracketBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SymbolLeverageBracketBean& from) { SymbolLeverageBracketBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SymbolLeverageBracketBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.SymbolLeverageBracketBean"; }

 protected:
  explicit SymbolLeverageBracketBean(::google::protobuf::Arena* arena);
  SymbolLeverageBracketBean(::google::protobuf::Arena* arena, const SymbolLeverageBracketBean& from);
  SymbolLeverageBracketBean(::google::protobuf::Arena* arena, SymbolLeverageBracketBean&& from) noexcept
      : SymbolLeverageBracketBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.trading.LeverageBracketBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::trading::LeverageBracketBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SymbolLeverageBracketBean& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::LeverageBracketBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ResQueryPositions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ResQueryPositions) */ {
 public:
  inline ResQueryPositions() : ResQueryPositions(nullptr) {}
  ~ResQueryPositions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResQueryPositions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResQueryPositions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResQueryPositions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResQueryPositions(const ResQueryPositions& from) : ResQueryPositions(nullptr, from) {}
  inline ResQueryPositions(ResQueryPositions&& from) noexcept
      : ResQueryPositions(nullptr, std::move(from)) {}
  inline ResQueryPositions& operator=(const ResQueryPositions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResQueryPositions& operator=(ResQueryPositions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResQueryPositions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResQueryPositions* internal_default_instance() {
    return reinterpret_cast<const ResQueryPositions*>(
        &_ResQueryPositions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ResQueryPositions& a, ResQueryPositions& b) { a.Swap(&b); }
  inline void Swap(ResQueryPositions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResQueryPositions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResQueryPositions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResQueryPositions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResQueryPositions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResQueryPositions& from) { ResQueryPositions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResQueryPositions* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ResQueryPositions"; }

 protected:
  explicit ResQueryPositions(::google::protobuf::Arena* arena);
  ResQueryPositions(::google::protobuf::Arena* arena, const ResQueryPositions& from);
  ResQueryPositions(::google::protobuf::Arena* arena, ResQueryPositions&& from) noexcept
      : ResQueryPositions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.trading.PositionBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::trading::PositionBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::trading::PositionBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::trading::PositionBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ResQueryPositions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResQueryPositions& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::PositionBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ResQueryLeverage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ResQueryLeverage) */ {
 public:
  inline ResQueryLeverage() : ResQueryLeverage(nullptr) {}
  ~ResQueryLeverage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResQueryLeverage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResQueryLeverage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResQueryLeverage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResQueryLeverage(const ResQueryLeverage& from) : ResQueryLeverage(nullptr, from) {}
  inline ResQueryLeverage(ResQueryLeverage&& from) noexcept
      : ResQueryLeverage(nullptr, std::move(from)) {}
  inline ResQueryLeverage& operator=(const ResQueryLeverage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResQueryLeverage& operator=(ResQueryLeverage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResQueryLeverage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResQueryLeverage* internal_default_instance() {
    return reinterpret_cast<const ResQueryLeverage*>(
        &_ResQueryLeverage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ResQueryLeverage& a, ResQueryLeverage& b) { a.Swap(&b); }
  inline void Swap(ResQueryLeverage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResQueryLeverage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResQueryLeverage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResQueryLeverage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResQueryLeverage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResQueryLeverage& from) { ResQueryLeverage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResQueryLeverage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ResQueryLeverage"; }

 protected:
  explicit ResQueryLeverage(::google::protobuf::Arena* arena);
  ResQueryLeverage(::google::protobuf::Arena* arena, const ResQueryLeverage& from);
  ResQueryLeverage(::google::protobuf::Arena* arena, ResQueryLeverage&& from) noexcept
      : ResQueryLeverage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.trading.LeverageBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::trading::LeverageBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::trading::LeverageBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::trading::LeverageBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ResQueryLeverage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResQueryLeverage& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::LeverageBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqSetLeverage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqSetLeverage) */ {
 public:
  inline ReqSetLeverage() : ReqSetLeverage(nullptr) {}
  ~ReqSetLeverage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqSetLeverage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqSetLeverage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqSetLeverage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqSetLeverage(const ReqSetLeverage& from) : ReqSetLeverage(nullptr, from) {}
  inline ReqSetLeverage(ReqSetLeverage&& from) noexcept
      : ReqSetLeverage(nullptr, std::move(from)) {}
  inline ReqSetLeverage& operator=(const ReqSetLeverage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSetLeverage& operator=(ReqSetLeverage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSetLeverage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSetLeverage* internal_default_instance() {
    return reinterpret_cast<const ReqSetLeverage*>(
        &_ReqSetLeverage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ReqSetLeverage& a, ReqSetLeverage& b) { a.Swap(&b); }
  inline void Swap(ReqSetLeverage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSetLeverage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSetLeverage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqSetLeverage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqSetLeverage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqSetLeverage& from) { ReqSetLeverage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqSetLeverage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqSetLeverage"; }

 protected:
  explicit ReqSetLeverage(::google::protobuf::Arena* arena);
  ReqSetLeverage(::google::protobuf::Arena* arena, const ReqSetLeverage& from);
  ReqSetLeverage(::google::protobuf::Arena* arena, ReqSetLeverage&& from) noexcept
      : ReqSetLeverage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.trading.LeverageBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::trading::LeverageBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::trading::LeverageBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::trading::LeverageBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqSetLeverage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqSetLeverage& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::LeverageBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class OrderBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.OrderBean) */ {
 public:
  inline OrderBean() : OrderBean(nullptr) {}
  ~OrderBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrderBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrderBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrderBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline OrderBean(const OrderBean& from) : OrderBean(nullptr, from) {}
  inline OrderBean(OrderBean&& from) noexcept
      : OrderBean(nullptr, std::move(from)) {}
  inline OrderBean& operator=(const OrderBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderBean& operator=(OrderBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderBean* internal_default_instance() {
    return reinterpret_cast<const OrderBean*>(
        &_OrderBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(OrderBean& a, OrderBean& b) { a.Swap(&b); }
  inline void Swap(OrderBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrderBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrderBean& from) { OrderBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrderBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.OrderBean"; }

 protected:
  explicit OrderBean(::google::protobuf::Arena* arena);
  OrderBean(::google::protobuf::Arena* arena, const OrderBean& from);
  OrderBean(::google::protobuf::Arena* arena, OrderBean&& from) noexcept
      : OrderBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConditionFieldNumber = 10,
    kSymbolFieldNumber = 1,
    kSideFieldNumber = 2,
    kOrderTypeFieldNumber = 3,
    kQuantityFieldNumber = 4,
    kCashQuantityFieldNumber = 5,
    kPriceFieldNumber = 6,
    kGoodTillDateFieldNumber = 8,
    kTifTypeFieldNumber = 7,
    kReduceOnlyFieldNumber = 9,
    kCreatedTimeFieldNumber = 11,
    kPositionSideFieldNumber = 12,
  };
  // repeated .lampyris.crypto.protocol.trading.ConditionTriggerBean condition = 10;
  int condition_size() const;
  private:
  int _internal_condition_size() const;

  public:
  void clear_condition() ;
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* mutable_condition(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>* mutable_condition();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>& _internal_condition() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>* _internal_mutable_condition();
  public:
  const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& condition(int index) const;
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* add_condition();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>& condition() const;
  // string symbol = 1;
  void clear_symbol() ;
  const std::string& symbol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* value);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // .lampyris.crypto.protocol.trading.OrderSide side = 2;
  void clear_side() ;
  ::lampyris::crypto::protocol::trading::OrderSide side() const;
  void set_side(::lampyris::crypto::protocol::trading::OrderSide value);

  private:
  ::lampyris::crypto::protocol::trading::OrderSide _internal_side() const;
  void _internal_set_side(::lampyris::crypto::protocol::trading::OrderSide value);

  public:
  // .lampyris.crypto.protocol.trading.OrderType orderType = 3;
  void clear_ordertype() ;
  ::lampyris::crypto::protocol::trading::OrderType ordertype() const;
  void set_ordertype(::lampyris::crypto::protocol::trading::OrderType value);

  private:
  ::lampyris::crypto::protocol::trading::OrderType _internal_ordertype() const;
  void _internal_set_ordertype(::lampyris::crypto::protocol::trading::OrderType value);

  public:
  // double quantity = 4;
  void clear_quantity() ;
  double quantity() const;
  void set_quantity(double value);

  private:
  double _internal_quantity() const;
  void _internal_set_quantity(double value);

  public:
  // double cashQuantity = 5;
  void clear_cashquantity() ;
  double cashquantity() const;
  void set_cashquantity(double value);

  private:
  double _internal_cashquantity() const;
  void _internal_set_cashquantity(double value);

  public:
  // double price = 6;
  void clear_price() ;
  double price() const;
  void set_price(double value);

  private:
  double _internal_price() const;
  void _internal_set_price(double value);

  public:
  // int64 goodTillDate = 8;
  void clear_goodtilldate() ;
  ::int64_t goodtilldate() const;
  void set_goodtilldate(::int64_t value);

  private:
  ::int64_t _internal_goodtilldate() const;
  void _internal_set_goodtilldate(::int64_t value);

  public:
  // .lampyris.crypto.protocol.trading.TimeInForceType tifType = 7;
  void clear_tiftype() ;
  ::lampyris::crypto::protocol::trading::TimeInForceType tiftype() const;
  void set_tiftype(::lampyris::crypto::protocol::trading::TimeInForceType value);

  private:
  ::lampyris::crypto::protocol::trading::TimeInForceType _internal_tiftype() const;
  void _internal_set_tiftype(::lampyris::crypto::protocol::trading::TimeInForceType value);

  public:
  // bool reduceOnly = 9;
  void clear_reduceonly() ;
  bool reduceonly() const;
  void set_reduceonly(bool value);

  private:
  bool _internal_reduceonly() const;
  void _internal_set_reduceonly(bool value);

  public:
  // int64 createdTime = 11;
  void clear_createdtime() ;
  ::int64_t createdtime() const;
  void set_createdtime(::int64_t value);

  private:
  ::int64_t _internal_createdtime() const;
  void _internal_set_createdtime(::int64_t value);

  public:
  // .lampyris.crypto.protocol.trading.PositionSide positionSide = 12;
  void clear_positionside() ;
  ::lampyris::crypto::protocol::trading::PositionSide positionside() const;
  void set_positionside(::lampyris::crypto::protocol::trading::PositionSide value);

  private:
  ::lampyris::crypto::protocol::trading::PositionSide _internal_positionside() const;
  void _internal_set_positionside(::lampyris::crypto::protocol::trading::PositionSide value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.OrderBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OrderBean& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::ConditionTriggerBean > condition_;
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    int side_;
    int ordertype_;
    double quantity_;
    double cashquantity_;
    double price_;
    ::int64_t goodtilldate_;
    int tiftype_;
    bool reduceonly_;
    ::int64_t createdtime_;
    int positionside_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ResQueryLeverageBracket final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ResQueryLeverageBracket) */ {
 public:
  inline ResQueryLeverageBracket() : ResQueryLeverageBracket(nullptr) {}
  ~ResQueryLeverageBracket() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResQueryLeverageBracket* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResQueryLeverageBracket));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResQueryLeverageBracket(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResQueryLeverageBracket(const ResQueryLeverageBracket& from) : ResQueryLeverageBracket(nullptr, from) {}
  inline ResQueryLeverageBracket(ResQueryLeverageBracket&& from) noexcept
      : ResQueryLeverageBracket(nullptr, std::move(from)) {}
  inline ResQueryLeverageBracket& operator=(const ResQueryLeverageBracket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResQueryLeverageBracket& operator=(ResQueryLeverageBracket&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResQueryLeverageBracket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResQueryLeverageBracket* internal_default_instance() {
    return reinterpret_cast<const ResQueryLeverageBracket*>(
        &_ResQueryLeverageBracket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ResQueryLeverageBracket& a, ResQueryLeverageBracket& b) { a.Swap(&b); }
  inline void Swap(ResQueryLeverageBracket* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResQueryLeverageBracket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResQueryLeverageBracket* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResQueryLeverageBracket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResQueryLeverageBracket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResQueryLeverageBracket& from) { ResQueryLeverageBracket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResQueryLeverageBracket* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ResQueryLeverageBracket"; }

 protected:
  explicit ResQueryLeverageBracket(::google::protobuf::Arena* arena);
  ResQueryLeverageBracket(::google::protobuf::Arena* arena, const ResQueryLeverageBracket& from);
  ResQueryLeverageBracket(::google::protobuf::Arena* arena, ResQueryLeverageBracket&& from) noexcept
      : ResQueryLeverageBracket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.trading.SymbolLeverageBracketBean beanList = 1;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>& beanlist() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ResQueryLeverageBracket)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResQueryLeverageBracket& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean > beanlist_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqPlaceOrder final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqPlaceOrder) */ {
 public:
  inline ReqPlaceOrder() : ReqPlaceOrder(nullptr) {}
  ~ReqPlaceOrder() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqPlaceOrder* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqPlaceOrder));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqPlaceOrder(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqPlaceOrder(const ReqPlaceOrder& from) : ReqPlaceOrder(nullptr, from) {}
  inline ReqPlaceOrder(ReqPlaceOrder&& from) noexcept
      : ReqPlaceOrder(nullptr, std::move(from)) {}
  inline ReqPlaceOrder& operator=(const ReqPlaceOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqPlaceOrder& operator=(ReqPlaceOrder&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqPlaceOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqPlaceOrder* internal_default_instance() {
    return reinterpret_cast<const ReqPlaceOrder*>(
        &_ReqPlaceOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ReqPlaceOrder& a, ReqPlaceOrder& b) { a.Swap(&b); }
  inline void Swap(ReqPlaceOrder* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqPlaceOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqPlaceOrder* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqPlaceOrder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqPlaceOrder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqPlaceOrder& from) { ReqPlaceOrder::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqPlaceOrder* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqPlaceOrder"; }

 protected:
  explicit ReqPlaceOrder(::google::protobuf::Arena* arena);
  ReqPlaceOrder(::google::protobuf::Arena* arena, const ReqPlaceOrder& from);
  ReqPlaceOrder(::google::protobuf::Arena* arena, ReqPlaceOrder&& from) noexcept
      : ReqPlaceOrder(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderBeanFieldNumber = 1,
  };
  // .lampyris.crypto.protocol.trading.OrderBean orderBean = 1;
  bool has_orderbean() const;
  void clear_orderbean() ;
  const ::lampyris::crypto::protocol::trading::OrderBean& orderbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::OrderBean* release_orderbean();
  ::lampyris::crypto::protocol::trading::OrderBean* mutable_orderbean();
  void set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  void unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  ::lampyris::crypto::protocol::trading::OrderBean* unsafe_arena_release_orderbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderBean& _internal_orderbean() const;
  ::lampyris::crypto::protocol::trading::OrderBean* _internal_mutable_orderbean();

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqPlaceOrder)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqPlaceOrder& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::lampyris::crypto::protocol::trading::OrderBean* orderbean_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ReqModifyOrder final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ReqModifyOrder) */ {
 public:
  inline ReqModifyOrder() : ReqModifyOrder(nullptr) {}
  ~ReqModifyOrder() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReqModifyOrder* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReqModifyOrder));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqModifyOrder(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqModifyOrder(const ReqModifyOrder& from) : ReqModifyOrder(nullptr, from) {}
  inline ReqModifyOrder(ReqModifyOrder&& from) noexcept
      : ReqModifyOrder(nullptr, std::move(from)) {}
  inline ReqModifyOrder& operator=(const ReqModifyOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqModifyOrder& operator=(ReqModifyOrder&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqModifyOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqModifyOrder* internal_default_instance() {
    return reinterpret_cast<const ReqModifyOrder*>(
        &_ReqModifyOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ReqModifyOrder& a, ReqModifyOrder& b) { a.Swap(&b); }
  inline void Swap(ReqModifyOrder* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqModifyOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqModifyOrder* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReqModifyOrder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqModifyOrder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqModifyOrder& from) { ReqModifyOrder::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReqModifyOrder* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ReqModifyOrder"; }

 protected:
  explicit ReqModifyOrder(::google::protobuf::Arena* arena);
  ReqModifyOrder(::google::protobuf::Arena* arena, const ReqModifyOrder& from);
  ReqModifyOrder(::google::protobuf::Arena* arena, ReqModifyOrder&& from) noexcept
      : ReqModifyOrder(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderBeanFieldNumber = 2,
    kOrderIdFieldNumber = 1,
  };
  // .lampyris.crypto.protocol.trading.OrderBean orderBean = 2;
  bool has_orderbean() const;
  void clear_orderbean() ;
  const ::lampyris::crypto::protocol::trading::OrderBean& orderbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::OrderBean* release_orderbean();
  ::lampyris::crypto::protocol::trading::OrderBean* mutable_orderbean();
  void set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  void unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  ::lampyris::crypto::protocol::trading::OrderBean* unsafe_arena_release_orderbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderBean& _internal_orderbean() const;
  ::lampyris::crypto::protocol::trading::OrderBean* _internal_mutable_orderbean();

  public:
  // int64 orderId = 1;
  void clear_orderid() ;
  ::int64_t orderid() const;
  void set_orderid(::int64_t value);

  private:
  ::int64_t _internal_orderid() const;
  void _internal_set_orderid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ReqModifyOrder)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqModifyOrder& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::lampyris::crypto::protocol::trading::OrderBean* orderbean_;
    ::int64_t orderid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class OrderStatusBean final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.OrderStatusBean) */ {
 public:
  inline OrderStatusBean() : OrderStatusBean(nullptr) {}
  ~OrderStatusBean() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrderStatusBean* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrderStatusBean));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrderStatusBean(
      ::google::protobuf::internal::ConstantInitialized);

  inline OrderStatusBean(const OrderStatusBean& from) : OrderStatusBean(nullptr, from) {}
  inline OrderStatusBean(OrderStatusBean&& from) noexcept
      : OrderStatusBean(nullptr, std::move(from)) {}
  inline OrderStatusBean& operator=(const OrderStatusBean& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderStatusBean& operator=(OrderStatusBean&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderStatusBean& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderStatusBean* internal_default_instance() {
    return reinterpret_cast<const OrderStatusBean*>(
        &_OrderStatusBean_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(OrderStatusBean& a, OrderStatusBean& b) { a.Swap(&b); }
  inline void Swap(OrderStatusBean* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderStatusBean* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderStatusBean* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrderStatusBean>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderStatusBean& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrderStatusBean& from) { OrderStatusBean::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrderStatusBean* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.OrderStatusBean"; }

 protected:
  explicit OrderStatusBean(::google::protobuf::Arena* arena);
  OrderStatusBean(::google::protobuf::Arena* arena, const OrderStatusBean& from);
  OrderStatusBean(::google::protobuf::Arena* arena, OrderStatusBean&& from) noexcept
      : OrderStatusBean(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderBeanFieldNumber = 1,
    kOrderIdFieldNumber = 2,
    kFilledQuantityFieldNumber = 4,
    kAvgFilledPriceFieldNumber = 5,
    kStatusFieldNumber = 3,
  };
  // .lampyris.crypto.protocol.trading.OrderBean orderBean = 1;
  bool has_orderbean() const;
  void clear_orderbean() ;
  const ::lampyris::crypto::protocol::trading::OrderBean& orderbean() const;
  PROTOBUF_NODISCARD ::lampyris::crypto::protocol::trading::OrderBean* release_orderbean();
  ::lampyris::crypto::protocol::trading::OrderBean* mutable_orderbean();
  void set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  void unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value);
  ::lampyris::crypto::protocol::trading::OrderBean* unsafe_arena_release_orderbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderBean& _internal_orderbean() const;
  ::lampyris::crypto::protocol::trading::OrderBean* _internal_mutable_orderbean();

  public:
  // int64 orderId = 2;
  void clear_orderid() ;
  ::int64_t orderid() const;
  void set_orderid(::int64_t value);

  private:
  ::int64_t _internal_orderid() const;
  void _internal_set_orderid(::int64_t value);

  public:
  // double filledQuantity = 4;
  void clear_filledquantity() ;
  double filledquantity() const;
  void set_filledquantity(double value);

  private:
  double _internal_filledquantity() const;
  void _internal_set_filledquantity(double value);

  public:
  // double avgFilledPrice = 5;
  void clear_avgfilledprice() ;
  double avgfilledprice() const;
  void set_avgfilledprice(double value);

  private:
  double _internal_avgfilledprice() const;
  void _internal_set_avgfilledprice(double value);

  public:
  // .lampyris.crypto.protocol.trading.OrderStatus status = 3;
  void clear_status() ;
  ::lampyris::crypto::protocol::trading::OrderStatus status() const;
  void set_status(::lampyris::crypto::protocol::trading::OrderStatus value);

  private:
  ::lampyris::crypto::protocol::trading::OrderStatus _internal_status() const;
  void _internal_set_status(::lampyris::crypto::protocol::trading::OrderStatus value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.OrderStatusBean)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OrderStatusBean& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::lampyris::crypto::protocol::trading::OrderBean* orderbean_;
    ::int64_t orderid_;
    double filledquantity_;
    double avgfilledprice_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};
// -------------------------------------------------------------------

class ResQueryOrders final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.trading.ResQueryOrders) */ {
 public:
  inline ResQueryOrders() : ResQueryOrders(nullptr) {}
  ~ResQueryOrders() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResQueryOrders* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResQueryOrders));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResQueryOrders(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResQueryOrders(const ResQueryOrders& from) : ResQueryOrders(nullptr, from) {}
  inline ResQueryOrders(ResQueryOrders&& from) noexcept
      : ResQueryOrders(nullptr, std::move(from)) {}
  inline ResQueryOrders& operator=(const ResQueryOrders& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResQueryOrders& operator=(ResQueryOrders&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResQueryOrders& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResQueryOrders* internal_default_instance() {
    return reinterpret_cast<const ResQueryOrders*>(
        &_ResQueryOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ResQueryOrders& a, ResQueryOrders& b) { a.Swap(&b); }
  inline void Swap(ResQueryOrders* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResQueryOrders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResQueryOrders* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResQueryOrders>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResQueryOrders& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResQueryOrders& from) { ResQueryOrders::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResQueryOrders* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.trading.ResQueryOrders"; }

 protected:
  explicit ResQueryOrders(::google::protobuf::Arena* arena);
  ResQueryOrders(::google::protobuf::Arena* arena, const ResQueryOrders& from);
  ResQueryOrders(::google::protobuf::Arena* arena, ResQueryOrders&& from) noexcept
      : ResQueryOrders(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeanListFieldNumber = 2,
    kIsActiveFieldNumber = 1,
  };
  // repeated .lampyris.crypto.protocol.trading.OrderStatusBean beanList = 2;
  int beanlist_size() const;
  private:
  int _internal_beanlist_size() const;

  public:
  void clear_beanlist() ;
  ::lampyris::crypto::protocol::trading::OrderStatusBean* mutable_beanlist(int index);
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>* mutable_beanlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>& _internal_beanlist() const;
  ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>* _internal_mutable_beanlist();
  public:
  const ::lampyris::crypto::protocol::trading::OrderStatusBean& beanlist(int index) const;
  ::lampyris::crypto::protocol::trading::OrderStatusBean* add_beanlist();
  const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>& beanlist() const;
  // bool isActive = 1;
  void clear_isactive() ;
  bool isactive() const;
  void set_isactive(bool value);

  private:
  bool _internal_isactive() const;
  void _internal_set_isactive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.trading.ResQueryOrders)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResQueryOrders& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lampyris::crypto::protocol::trading::OrderStatusBean > beanlist_;
    bool isactive_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ConditionTriggerBean

// .lampyris.crypto.protocol.trading.ConditionOrderTriggerType type = 1;
inline void ConditionTriggerBean::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::lampyris::crypto::protocol::trading::ConditionOrderTriggerType ConditionTriggerBean::type() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ConditionTriggerBean.type)
  return _internal_type();
}
inline void ConditionTriggerBean::set_type(::lampyris::crypto::protocol::trading::ConditionOrderTriggerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ConditionTriggerBean.type)
}
inline ::lampyris::crypto::protocol::trading::ConditionOrderTriggerType ConditionTriggerBean::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::ConditionOrderTriggerType>(_impl_.type_);
}
inline void ConditionTriggerBean::_internal_set_type(::lampyris::crypto::protocol::trading::ConditionOrderTriggerType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string value = 2;
inline void ConditionTriggerBean::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ConditionTriggerBean::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ConditionTriggerBean.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConditionTriggerBean::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ConditionTriggerBean.value)
}
inline std::string* ConditionTriggerBean::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ConditionTriggerBean.value)
  return _s;
}
inline const std::string& ConditionTriggerBean::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void ConditionTriggerBean::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* ConditionTriggerBean::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* ConditionTriggerBean::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ConditionTriggerBean.value)
  return _impl_.value_.Release();
}
inline void ConditionTriggerBean::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ConditionTriggerBean.value)
}

// -------------------------------------------------------------------

// OrderBean

// string symbol = 1;
inline void OrderBean::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& OrderBean::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderBean::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.symbol)
}
inline std::string* OrderBean::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.OrderBean.symbol)
  return _s;
}
inline const std::string& OrderBean::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void OrderBean::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* OrderBean::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* OrderBean::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.OrderBean.symbol)
  return _impl_.symbol_.Release();
}
inline void OrderBean::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.OrderBean.symbol)
}

// .lampyris.crypto.protocol.trading.OrderSide side = 2;
inline void OrderBean::clear_side() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.side_ = 0;
}
inline ::lampyris::crypto::protocol::trading::OrderSide OrderBean::side() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.side)
  return _internal_side();
}
inline void OrderBean::set_side(::lampyris::crypto::protocol::trading::OrderSide value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.side)
}
inline ::lampyris::crypto::protocol::trading::OrderSide OrderBean::_internal_side() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::OrderSide>(_impl_.side_);
}
inline void OrderBean::_internal_set_side(::lampyris::crypto::protocol::trading::OrderSide value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.side_ = value;
}

// .lampyris.crypto.protocol.trading.OrderType orderType = 3;
inline void OrderBean::clear_ordertype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordertype_ = 0;
}
inline ::lampyris::crypto::protocol::trading::OrderType OrderBean::ordertype() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.orderType)
  return _internal_ordertype();
}
inline void OrderBean::set_ordertype(::lampyris::crypto::protocol::trading::OrderType value) {
  _internal_set_ordertype(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.orderType)
}
inline ::lampyris::crypto::protocol::trading::OrderType OrderBean::_internal_ordertype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::OrderType>(_impl_.ordertype_);
}
inline void OrderBean::_internal_set_ordertype(::lampyris::crypto::protocol::trading::OrderType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordertype_ = value;
}

// double quantity = 4;
inline void OrderBean::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
}
inline double OrderBean::quantity() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.quantity)
  return _internal_quantity();
}
inline void OrderBean::set_quantity(double value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.quantity)
}
inline double OrderBean::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void OrderBean::_internal_set_quantity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// double cashQuantity = 5;
inline void OrderBean::clear_cashquantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cashquantity_ = 0;
}
inline double OrderBean::cashquantity() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.cashQuantity)
  return _internal_cashquantity();
}
inline void OrderBean::set_cashquantity(double value) {
  _internal_set_cashquantity(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.cashQuantity)
}
inline double OrderBean::_internal_cashquantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cashquantity_;
}
inline void OrderBean::_internal_set_cashquantity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cashquantity_ = value;
}

// double price = 6;
inline void OrderBean::clear_price() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.price_ = 0;
}
inline double OrderBean::price() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.price)
  return _internal_price();
}
inline void OrderBean::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.price)
}
inline double OrderBean::_internal_price() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.price_;
}
inline void OrderBean::_internal_set_price(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.price_ = value;
}

// .lampyris.crypto.protocol.trading.TimeInForceType tifType = 7;
inline void OrderBean::clear_tiftype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tiftype_ = 0;
}
inline ::lampyris::crypto::protocol::trading::TimeInForceType OrderBean::tiftype() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.tifType)
  return _internal_tiftype();
}
inline void OrderBean::set_tiftype(::lampyris::crypto::protocol::trading::TimeInForceType value) {
  _internal_set_tiftype(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.tifType)
}
inline ::lampyris::crypto::protocol::trading::TimeInForceType OrderBean::_internal_tiftype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::TimeInForceType>(_impl_.tiftype_);
}
inline void OrderBean::_internal_set_tiftype(::lampyris::crypto::protocol::trading::TimeInForceType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tiftype_ = value;
}

// int64 goodTillDate = 8;
inline void OrderBean::clear_goodtilldate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.goodtilldate_ = ::int64_t{0};
}
inline ::int64_t OrderBean::goodtilldate() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.goodTillDate)
  return _internal_goodtilldate();
}
inline void OrderBean::set_goodtilldate(::int64_t value) {
  _internal_set_goodtilldate(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.goodTillDate)
}
inline ::int64_t OrderBean::_internal_goodtilldate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.goodtilldate_;
}
inline void OrderBean::_internal_set_goodtilldate(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.goodtilldate_ = value;
}

// bool reduceOnly = 9;
inline void OrderBean::clear_reduceonly() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduceonly_ = false;
}
inline bool OrderBean::reduceonly() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.reduceOnly)
  return _internal_reduceonly();
}
inline void OrderBean::set_reduceonly(bool value) {
  _internal_set_reduceonly(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.reduceOnly)
}
inline bool OrderBean::_internal_reduceonly() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reduceonly_;
}
inline void OrderBean::_internal_set_reduceonly(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduceonly_ = value;
}

// repeated .lampyris.crypto.protocol.trading.ConditionTriggerBean condition = 10;
inline int OrderBean::_internal_condition_size() const {
  return _internal_condition().size();
}
inline int OrderBean::condition_size() const {
  return _internal_condition_size();
}
inline void OrderBean::clear_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_.Clear();
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* OrderBean::mutable_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.OrderBean.condition)
  return _internal_mutable_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>* OrderBean::mutable_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.OrderBean.condition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_condition();
}
inline const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& OrderBean::condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.condition)
  return _internal_condition().Get(index);
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* OrderBean::add_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* _add = _internal_mutable_condition()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.OrderBean.condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>& OrderBean::condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.OrderBean.condition)
  return _internal_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>&
OrderBean::_internal_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.condition_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::ConditionTriggerBean>*
OrderBean::_internal_mutable_condition() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.condition_;
}

// int64 createdTime = 11;
inline void OrderBean::clear_createdtime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.createdtime_ = ::int64_t{0};
}
inline ::int64_t OrderBean::createdtime() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.createdTime)
  return _internal_createdtime();
}
inline void OrderBean::set_createdtime(::int64_t value) {
  _internal_set_createdtime(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.createdTime)
}
inline ::int64_t OrderBean::_internal_createdtime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.createdtime_;
}
inline void OrderBean::_internal_set_createdtime(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.createdtime_ = value;
}

// .lampyris.crypto.protocol.trading.PositionSide positionSide = 12;
inline void OrderBean::clear_positionside() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positionside_ = 0;
}
inline ::lampyris::crypto::protocol::trading::PositionSide OrderBean::positionside() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderBean.positionSide)
  return _internal_positionside();
}
inline void OrderBean::set_positionside(::lampyris::crypto::protocol::trading::PositionSide value) {
  _internal_set_positionside(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderBean.positionSide)
}
inline ::lampyris::crypto::protocol::trading::PositionSide OrderBean::_internal_positionside() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::PositionSide>(_impl_.positionside_);
}
inline void OrderBean::_internal_set_positionside(::lampyris::crypto::protocol::trading::PositionSide value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positionside_ = value;
}

// -------------------------------------------------------------------

// OrderStatusBean

// .lampyris.crypto.protocol.trading.OrderBean orderBean = 1;
inline bool OrderStatusBean::has_orderbean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbean_ != nullptr);
  return value;
}
inline void OrderStatusBean::clear_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orderbean_ != nullptr) _impl_.orderbean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& OrderStatusBean::_internal_orderbean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lampyris::crypto::protocol::trading::OrderBean* p = _impl_.orderbean_;
  return p != nullptr ? *p : reinterpret_cast<const ::lampyris::crypto::protocol::trading::OrderBean&>(::lampyris::crypto::protocol::trading::_OrderBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& OrderStatusBean::orderbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderStatusBean.orderBean)
  return _internal_orderbean();
}
inline void OrderStatusBean::unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orderbean_);
  }
  _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.trading.OrderStatusBean.orderBean)
}
inline ::lampyris::crypto::protocol::trading::OrderBean* OrderStatusBean::release_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* released = _impl_.orderbean_;
  _impl_.orderbean_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* OrderStatusBean::unsafe_arena_release_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.OrderStatusBean.orderBean)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* temp = _impl_.orderbean_;
  _impl_.orderbean_ = nullptr;
  return temp;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* OrderStatusBean::_internal_mutable_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orderbean_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderBean>(GetArena());
    _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(p);
  }
  return _impl_.orderbean_;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* OrderStatusBean::mutable_orderbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* _msg = _internal_mutable_orderbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.OrderStatusBean.orderBean)
  return _msg;
}
inline void OrderStatusBean::set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orderbean_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(value);
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.OrderStatusBean.orderBean)
}

// int64 orderId = 2;
inline void OrderStatusBean::clear_orderid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orderid_ = ::int64_t{0};
}
inline ::int64_t OrderStatusBean::orderid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderStatusBean.orderId)
  return _internal_orderid();
}
inline void OrderStatusBean::set_orderid(::int64_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderStatusBean.orderId)
}
inline ::int64_t OrderStatusBean::_internal_orderid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.orderid_;
}
inline void OrderStatusBean::_internal_set_orderid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orderid_ = value;
}

// .lampyris.crypto.protocol.trading.OrderStatus status = 3;
inline void OrderStatusBean::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::lampyris::crypto::protocol::trading::OrderStatus OrderStatusBean::status() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderStatusBean.status)
  return _internal_status();
}
inline void OrderStatusBean::set_status(::lampyris::crypto::protocol::trading::OrderStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderStatusBean.status)
}
inline ::lampyris::crypto::protocol::trading::OrderStatus OrderStatusBean::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::OrderStatus>(_impl_.status_);
}
inline void OrderStatusBean::_internal_set_status(::lampyris::crypto::protocol::trading::OrderStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// double filledQuantity = 4;
inline void OrderStatusBean::clear_filledquantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filledquantity_ = 0;
}
inline double OrderStatusBean::filledquantity() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderStatusBean.filledQuantity)
  return _internal_filledquantity();
}
inline void OrderStatusBean::set_filledquantity(double value) {
  _internal_set_filledquantity(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderStatusBean.filledQuantity)
}
inline double OrderStatusBean::_internal_filledquantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filledquantity_;
}
inline void OrderStatusBean::_internal_set_filledquantity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filledquantity_ = value;
}

// double avgFilledPrice = 5;
inline void OrderStatusBean::clear_avgfilledprice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avgfilledprice_ = 0;
}
inline double OrderStatusBean::avgfilledprice() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.OrderStatusBean.avgFilledPrice)
  return _internal_avgfilledprice();
}
inline void OrderStatusBean::set_avgfilledprice(double value) {
  _internal_set_avgfilledprice(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.OrderStatusBean.avgFilledPrice)
}
inline double OrderStatusBean::_internal_avgfilledprice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avgfilledprice_;
}
inline void OrderStatusBean::_internal_set_avgfilledprice(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avgfilledprice_ = value;
}

// -------------------------------------------------------------------

// ReqPlaceOrder

// .lampyris.crypto.protocol.trading.OrderBean orderBean = 1;
inline bool ReqPlaceOrder::has_orderbean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbean_ != nullptr);
  return value;
}
inline void ReqPlaceOrder::clear_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orderbean_ != nullptr) _impl_.orderbean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& ReqPlaceOrder::_internal_orderbean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lampyris::crypto::protocol::trading::OrderBean* p = _impl_.orderbean_;
  return p != nullptr ? *p : reinterpret_cast<const ::lampyris::crypto::protocol::trading::OrderBean&>(::lampyris::crypto::protocol::trading::_OrderBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& ReqPlaceOrder::orderbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqPlaceOrder.orderBean)
  return _internal_orderbean();
}
inline void ReqPlaceOrder::unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orderbean_);
  }
  _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.trading.ReqPlaceOrder.orderBean)
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqPlaceOrder::release_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* released = _impl_.orderbean_;
  _impl_.orderbean_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqPlaceOrder::unsafe_arena_release_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqPlaceOrder.orderBean)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* temp = _impl_.orderbean_;
  _impl_.orderbean_ = nullptr;
  return temp;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqPlaceOrder::_internal_mutable_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orderbean_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderBean>(GetArena());
    _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(p);
  }
  return _impl_.orderbean_;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqPlaceOrder::mutable_orderbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* _msg = _internal_mutable_orderbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqPlaceOrder.orderBean)
  return _msg;
}
inline void ReqPlaceOrder::set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orderbean_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(value);
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqPlaceOrder.orderBean)
}

// -------------------------------------------------------------------

// ReqModifyOrder

// int64 orderId = 1;
inline void ReqModifyOrder::clear_orderid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orderid_ = ::int64_t{0};
}
inline ::int64_t ReqModifyOrder::orderid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqModifyOrder.orderId)
  return _internal_orderid();
}
inline void ReqModifyOrder::set_orderid(::int64_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqModifyOrder.orderId)
}
inline ::int64_t ReqModifyOrder::_internal_orderid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.orderid_;
}
inline void ReqModifyOrder::_internal_set_orderid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orderid_ = value;
}

// .lampyris.crypto.protocol.trading.OrderBean orderBean = 2;
inline bool ReqModifyOrder::has_orderbean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbean_ != nullptr);
  return value;
}
inline void ReqModifyOrder::clear_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orderbean_ != nullptr) _impl_.orderbean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& ReqModifyOrder::_internal_orderbean() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lampyris::crypto::protocol::trading::OrderBean* p = _impl_.orderbean_;
  return p != nullptr ? *p : reinterpret_cast<const ::lampyris::crypto::protocol::trading::OrderBean&>(::lampyris::crypto::protocol::trading::_OrderBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& ReqModifyOrder::orderbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqModifyOrder.orderBean)
  return _internal_orderbean();
}
inline void ReqModifyOrder::unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orderbean_);
  }
  _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.trading.ReqModifyOrder.orderBean)
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqModifyOrder::release_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* released = _impl_.orderbean_;
  _impl_.orderbean_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqModifyOrder::unsafe_arena_release_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqModifyOrder.orderBean)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* temp = _impl_.orderbean_;
  _impl_.orderbean_ = nullptr;
  return temp;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqModifyOrder::_internal_mutable_orderbean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orderbean_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderBean>(GetArena());
    _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(p);
  }
  return _impl_.orderbean_;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* ReqModifyOrder::mutable_orderbean() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lampyris::crypto::protocol::trading::OrderBean* _msg = _internal_mutable_orderbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqModifyOrder.orderBean)
  return _msg;
}
inline void ReqModifyOrder::set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orderbean_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.orderbean_ = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(value);
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqModifyOrder.orderBean)
}

// -------------------------------------------------------------------

// ReqCancelOrder

// int64 orderId = 1;
inline void ReqCancelOrder::clear_orderid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orderid_ = ::int64_t{0};
}
inline ::int64_t ReqCancelOrder::orderid() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqCancelOrder.orderId)
  return _internal_orderid();
}
inline void ReqCancelOrder::set_orderid(::int64_t value) {
  _internal_set_orderid(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqCancelOrder.orderId)
}
inline ::int64_t ReqCancelOrder::_internal_orderid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.orderid_;
}
inline void ReqCancelOrder::_internal_set_orderid(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orderid_ = value;
}

// -------------------------------------------------------------------

// ReqOneKeyClosePosition

// repeated string symbols = 1;
inline int ReqOneKeyClosePosition::_internal_symbols_size() const {
  return _internal_symbols().size();
}
inline int ReqOneKeyClosePosition::symbols_size() const {
  return _internal_symbols_size();
}
inline void ReqOneKeyClosePosition::clear_symbols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbols_.Clear();
}
inline std::string* ReqOneKeyClosePosition::add_symbols() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_symbols()->Add();
  // @@protoc_insertion_point(field_add_mutable:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
  return _s;
}
inline const std::string& ReqOneKeyClosePosition::symbols(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
  return _internal_symbols().Get(index);
}
inline std::string* ReqOneKeyClosePosition::mutable_symbols(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
  return _internal_mutable_symbols()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ReqOneKeyClosePosition::set_symbols(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_symbols()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
}
template <typename Arg_, typename... Args_>
inline void ReqOneKeyClosePosition::add_symbols(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_symbols(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReqOneKeyClosePosition::symbols() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
  return _internal_symbols();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReqOneKeyClosePosition::mutable_symbols() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.ReqOneKeyClosePosition.symbols)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_symbols();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReqOneKeyClosePosition::_internal_symbols() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbols_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReqOneKeyClosePosition::_internal_mutable_symbols() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.symbols_;
}

// -------------------------------------------------------------------

// ReqQueryActiveOrders

// string symbol = 1;
inline void ReqQueryActiveOrders::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqQueryActiveOrders::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryActiveOrders.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqQueryActiveOrders::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryActiveOrders.symbol)
}
inline std::string* ReqQueryActiveOrders::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqQueryActiveOrders.symbol)
  return _s;
}
inline const std::string& ReqQueryActiveOrders::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqQueryActiveOrders::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqQueryActiveOrders::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqQueryActiveOrders::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqQueryActiveOrders.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqQueryActiveOrders::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqQueryActiveOrders.symbol)
}

// -------------------------------------------------------------------

// ResQueryOrders

// bool isActive = 1;
inline void ResQueryOrders::clear_isactive() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.isactive_ = false;
}
inline bool ResQueryOrders::isactive() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ResQueryOrders.isActive)
  return _internal_isactive();
}
inline void ResQueryOrders::set_isactive(bool value) {
  _internal_set_isactive(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ResQueryOrders.isActive)
}
inline bool ResQueryOrders::_internal_isactive() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.isactive_;
}
inline void ResQueryOrders::_internal_set_isactive(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.isactive_ = value;
}

// repeated .lampyris.crypto.protocol.trading.OrderStatusBean beanList = 2;
inline int ResQueryOrders::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ResQueryOrders::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ResQueryOrders::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* ResQueryOrders::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ResQueryOrders.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>* ResQueryOrders::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.ResQueryOrders.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::trading::OrderStatusBean& ResQueryOrders::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ResQueryOrders.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* ResQueryOrders::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::OrderStatusBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.ResQueryOrders.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>& ResQueryOrders::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.ResQueryOrders.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>&
ResQueryOrders::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::OrderStatusBean>*
ResQueryOrders::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// ReqQueryHistoricalOrders

// string symbol = 1;
inline void ReqQueryHistoricalOrders::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqQueryHistoricalOrders::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqQueryHistoricalOrders::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.symbol)
}
inline std::string* ReqQueryHistoricalOrders::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.symbol)
  return _s;
}
inline const std::string& ReqQueryHistoricalOrders::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqQueryHistoricalOrders::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqQueryHistoricalOrders::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqQueryHistoricalOrders::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqQueryHistoricalOrders::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.symbol)
}

// int64 beginTime = 2;
inline void ReqQueryHistoricalOrders::clear_begintime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.begintime_ = ::int64_t{0};
}
inline ::int64_t ReqQueryHistoricalOrders::begintime() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.beginTime)
  return _internal_begintime();
}
inline void ReqQueryHistoricalOrders::set_begintime(::int64_t value) {
  _internal_set_begintime(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.beginTime)
}
inline ::int64_t ReqQueryHistoricalOrders::_internal_begintime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.begintime_;
}
inline void ReqQueryHistoricalOrders::_internal_set_begintime(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.begintime_ = value;
}

// int64 endTime = 3;
inline void ReqQueryHistoricalOrders::clear_endtime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endtime_ = ::int64_t{0};
}
inline ::int64_t ReqQueryHistoricalOrders::endtime() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.endTime)
  return _internal_endtime();
}
inline void ReqQueryHistoricalOrders::set_endtime(::int64_t value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders.endTime)
}
inline ::int64_t ReqQueryHistoricalOrders::_internal_endtime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.endtime_;
}
inline void ReqQueryHistoricalOrders::_internal_set_endtime(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endtime_ = value;
}

// -------------------------------------------------------------------

// ReqQueryPositions

// string symbol = 1;
inline void ReqQueryPositions::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqQueryPositions::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryPositions.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqQueryPositions::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryPositions.symbol)
}
inline std::string* ReqQueryPositions::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqQueryPositions.symbol)
  return _s;
}
inline const std::string& ReqQueryPositions::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqQueryPositions::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqQueryPositions::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqQueryPositions::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqQueryPositions.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqQueryPositions::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqQueryPositions.symbol)
}

// -------------------------------------------------------------------

// PositionBean

// string symbol = 1;
inline void PositionBean::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& PositionBean::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionBean::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.symbol)
}
inline std::string* PositionBean::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.PositionBean.symbol)
  return _s;
}
inline const std::string& PositionBean::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void PositionBean::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* PositionBean::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* PositionBean::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.PositionBean.symbol)
  return _impl_.symbol_.Release();
}
inline void PositionBean::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.PositionBean.symbol)
}

// .lampyris.crypto.protocol.trading.PositionSide positionSide = 2;
inline void PositionBean::clear_positionside() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positionside_ = 0;
}
inline ::lampyris::crypto::protocol::trading::PositionSide PositionBean::positionside() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.positionSide)
  return _internal_positionside();
}
inline void PositionBean::set_positionside(::lampyris::crypto::protocol::trading::PositionSide value) {
  _internal_set_positionside(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.positionSide)
}
inline ::lampyris::crypto::protocol::trading::PositionSide PositionBean::_internal_positionside() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::lampyris::crypto::protocol::trading::PositionSide>(_impl_.positionside_);
}
inline void PositionBean::_internal_set_positionside(::lampyris::crypto::protocol::trading::PositionSide value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.positionside_ = value;
}

// double quantity = 3;
inline void PositionBean::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
}
inline double PositionBean::quantity() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.quantity)
  return _internal_quantity();
}
inline void PositionBean::set_quantity(double value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.quantity)
}
inline double PositionBean::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void PositionBean::_internal_set_quantity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// double unrealizedPnL = 4;
inline void PositionBean::clear_unrealizedpnl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unrealizedpnl_ = 0;
}
inline double PositionBean::unrealizedpnl() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.unrealizedPnL)
  return _internal_unrealizedpnl();
}
inline void PositionBean::set_unrealizedpnl(double value) {
  _internal_set_unrealizedpnl(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.unrealizedPnL)
}
inline double PositionBean::_internal_unrealizedpnl() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unrealizedpnl_;
}
inline void PositionBean::_internal_set_unrealizedpnl(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unrealizedpnl_ = value;
}

// double realizedPnL = 5;
inline void PositionBean::clear_realizedpnl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.realizedpnl_ = 0;
}
inline double PositionBean::realizedpnl() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.realizedPnL)
  return _internal_realizedpnl();
}
inline void PositionBean::set_realizedpnl(double value) {
  _internal_set_realizedpnl(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.realizedPnL)
}
inline double PositionBean::_internal_realizedpnl() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.realizedpnl_;
}
inline void PositionBean::_internal_set_realizedpnl(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.realizedpnl_ = value;
}

// double initialMargin = 6;
inline void PositionBean::clear_initialmargin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initialmargin_ = 0;
}
inline double PositionBean::initialmargin() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.initialMargin)
  return _internal_initialmargin();
}
inline void PositionBean::set_initialmargin(double value) {
  _internal_set_initialmargin(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.initialMargin)
}
inline double PositionBean::_internal_initialmargin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initialmargin_;
}
inline void PositionBean::_internal_set_initialmargin(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initialmargin_ = value;
}

// double maintenanceMargin = 7;
inline void PositionBean::clear_maintenancemargin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenancemargin_ = 0;
}
inline double PositionBean::maintenancemargin() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.maintenanceMargin)
  return _internal_maintenancemargin();
}
inline void PositionBean::set_maintenancemargin(double value) {
  _internal_set_maintenancemargin(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.maintenanceMargin)
}
inline double PositionBean::_internal_maintenancemargin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maintenancemargin_;
}
inline void PositionBean::_internal_set_maintenancemargin(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenancemargin_ = value;
}

// double costPrice = 8;
inline void PositionBean::clear_costprice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.costprice_ = 0;
}
inline double PositionBean::costprice() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.costPrice)
  return _internal_costprice();
}
inline void PositionBean::set_costprice(double value) {
  _internal_set_costprice(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.costPrice)
}
inline double PositionBean::_internal_costprice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.costprice_;
}
inline void PositionBean::_internal_set_costprice(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.costprice_ = value;
}

// double markPrice = 9;
inline void PositionBean::clear_markprice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.markprice_ = 0;
}
inline double PositionBean::markprice() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.markPrice)
  return _internal_markprice();
}
inline void PositionBean::set_markprice(double value) {
  _internal_set_markprice(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.markPrice)
}
inline double PositionBean::_internal_markprice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.markprice_;
}
inline void PositionBean::_internal_set_markprice(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.markprice_ = value;
}

// int32 autoDeleveragingLevel = 10;
inline void PositionBean::clear_autodeleveraginglevel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.autodeleveraginglevel_ = 0;
}
inline ::int32_t PositionBean::autodeleveraginglevel() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.autoDeleveragingLevel)
  return _internal_autodeleveraginglevel();
}
inline void PositionBean::set_autodeleveraginglevel(::int32_t value) {
  _internal_set_autodeleveraginglevel(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.autoDeleveragingLevel)
}
inline ::int32_t PositionBean::_internal_autodeleveraginglevel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.autodeleveraginglevel_;
}
inline void PositionBean::_internal_set_autodeleveraginglevel(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.autodeleveraginglevel_ = value;
}

// double liquidationPrice = 11;
inline void PositionBean::clear_liquidationprice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.liquidationprice_ = 0;
}
inline double PositionBean::liquidationprice() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.liquidationPrice)
  return _internal_liquidationprice();
}
inline void PositionBean::set_liquidationprice(double value) {
  _internal_set_liquidationprice(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.liquidationPrice)
}
inline double PositionBean::_internal_liquidationprice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.liquidationprice_;
}
inline void PositionBean::_internal_set_liquidationprice(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.liquidationprice_ = value;
}

// int64 updateTime = 12;
inline void PositionBean::clear_updatetime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updatetime_ = ::int64_t{0};
}
inline ::int64_t PositionBean::updatetime() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.PositionBean.updateTime)
  return _internal_updatetime();
}
inline void PositionBean::set_updatetime(::int64_t value) {
  _internal_set_updatetime(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.PositionBean.updateTime)
}
inline ::int64_t PositionBean::_internal_updatetime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updatetime_;
}
inline void PositionBean::_internal_set_updatetime(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updatetime_ = value;
}

// -------------------------------------------------------------------

// ResQueryPositions

// repeated .lampyris.crypto.protocol.trading.PositionBean beanList = 1;
inline int ResQueryPositions::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ResQueryPositions::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ResQueryPositions::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::trading::PositionBean* ResQueryPositions::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ResQueryPositions.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>* ResQueryPositions::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.ResQueryPositions.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::trading::PositionBean& ResQueryPositions::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ResQueryPositions.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::trading::PositionBean* ResQueryPositions::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::PositionBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.ResQueryPositions.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>& ResQueryPositions::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.ResQueryPositions.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>&
ResQueryPositions::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::PositionBean>*
ResQueryPositions::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// LeverageBean

// string symbol = 1;
inline void LeverageBean::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& LeverageBean::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.LeverageBean.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LeverageBean::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.LeverageBean.symbol)
}
inline std::string* LeverageBean::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.LeverageBean.symbol)
  return _s;
}
inline const std::string& LeverageBean::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void LeverageBean::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* LeverageBean::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* LeverageBean::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.LeverageBean.symbol)
  return _impl_.symbol_.Release();
}
inline void LeverageBean::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.LeverageBean.symbol)
}

// int32 leverage = 2;
inline void LeverageBean::clear_leverage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leverage_ = 0;
}
inline ::int32_t LeverageBean::leverage() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.LeverageBean.leverage)
  return _internal_leverage();
}
inline void LeverageBean::set_leverage(::int32_t value) {
  _internal_set_leverage(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.LeverageBean.leverage)
}
inline ::int32_t LeverageBean::_internal_leverage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leverage_;
}
inline void LeverageBean::_internal_set_leverage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leverage_ = value;
}

// double maxNotional = 3;
inline void LeverageBean::clear_maxnotional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maxnotional_ = 0;
}
inline double LeverageBean::maxnotional() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.LeverageBean.maxNotional)
  return _internal_maxnotional();
}
inline void LeverageBean::set_maxnotional(double value) {
  _internal_set_maxnotional(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.LeverageBean.maxNotional)
}
inline double LeverageBean::_internal_maxnotional() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maxnotional_;
}
inline void LeverageBean::_internal_set_maxnotional(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maxnotional_ = value;
}

// -------------------------------------------------------------------

// ReqSetLeverage

// repeated .lampyris.crypto.protocol.trading.LeverageBean beanList = 1;
inline int ReqSetLeverage::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ReqSetLeverage::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ReqSetLeverage::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* ReqSetLeverage::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqSetLeverage.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>* ReqSetLeverage::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.ReqSetLeverage.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::trading::LeverageBean& ReqSetLeverage::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqSetLeverage.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* ReqSetLeverage::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::LeverageBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.ReqSetLeverage.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>& ReqSetLeverage::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.ReqSetLeverage.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>&
ReqSetLeverage::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>*
ReqSetLeverage::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// ReqQueryLeverage

// string symbol = 1;
inline void ReqQueryLeverage::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqQueryLeverage::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryLeverage.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqQueryLeverage::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryLeverage.symbol)
}
inline std::string* ReqQueryLeverage::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqQueryLeverage.symbol)
  return _s;
}
inline const std::string& ReqQueryLeverage::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqQueryLeverage::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqQueryLeverage::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqQueryLeverage::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqQueryLeverage.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqQueryLeverage::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqQueryLeverage.symbol)
}

// -------------------------------------------------------------------

// ResQueryLeverage

// repeated .lampyris.crypto.protocol.trading.LeverageBean beanList = 1;
inline int ResQueryLeverage::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ResQueryLeverage::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ResQueryLeverage::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* ResQueryLeverage::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ResQueryLeverage.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>* ResQueryLeverage::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.ResQueryLeverage.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::trading::LeverageBean& ResQueryLeverage::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ResQueryLeverage.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* ResQueryLeverage::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::LeverageBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.ResQueryLeverage.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>& ResQueryLeverage::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.ResQueryLeverage.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>&
ResQueryLeverage::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBean>*
ResQueryLeverage::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// ReqQueryLeverageBracket

// string symbol = 1;
inline void ReqQueryLeverageBracket::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& ReqQueryLeverageBracket::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqQueryLeverageBracket::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket.symbol)
}
inline std::string* ReqQueryLeverageBracket::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket.symbol)
  return _s;
}
inline const std::string& ReqQueryLeverageBracket::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void ReqQueryLeverageBracket::_internal_set_symbol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.Set(value, GetArena());
}
inline std::string* ReqQueryLeverageBracket::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.symbol_.Mutable( GetArena());
}
inline std::string* ReqQueryLeverageBracket::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket.symbol)
  return _impl_.symbol_.Release();
}
inline void ReqQueryLeverageBracket::set_allocated_symbol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:lampyris.crypto.protocol.trading.ReqQueryLeverageBracket.symbol)
}

// -------------------------------------------------------------------

// ResQueryLeverageBracket

// repeated .lampyris.crypto.protocol.trading.SymbolLeverageBracketBean beanList = 1;
inline int ResQueryLeverageBracket::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int ResQueryLeverageBracket::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void ResQueryLeverageBracket::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* ResQueryLeverageBracket::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.ResQueryLeverageBracket.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>* ResQueryLeverageBracket::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.ResQueryLeverageBracket.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& ResQueryLeverageBracket::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.ResQueryLeverageBracket.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* ResQueryLeverageBracket::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.ResQueryLeverageBracket.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>& ResQueryLeverageBracket::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.ResQueryLeverageBracket.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>&
ResQueryLeverageBracket::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>*
ResQueryLeverageBracket::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// SymbolLeverageBracketBean

// repeated .lampyris.crypto.protocol.trading.LeverageBracketBean beanList = 1;
inline int SymbolLeverageBracketBean::_internal_beanlist_size() const {
  return _internal_beanlist().size();
}
inline int SymbolLeverageBracketBean::beanlist_size() const {
  return _internal_beanlist_size();
}
inline void SymbolLeverageBracketBean::clear_beanlist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.beanlist_.Clear();
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* SymbolLeverageBracketBean::mutable_beanlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean.beanList)
  return _internal_mutable_beanlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>* SymbolLeverageBracketBean::mutable_beanlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean.beanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_beanlist();
}
inline const ::lampyris::crypto::protocol::trading::LeverageBracketBean& SymbolLeverageBracketBean::beanlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean.beanList)
  return _internal_beanlist().Get(index);
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* SymbolLeverageBracketBean::add_beanlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* _add = _internal_mutable_beanlist()->Add();
  // @@protoc_insertion_point(field_add:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean.beanList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>& SymbolLeverageBracketBean::beanlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lampyris.crypto.protocol.trading.SymbolLeverageBracketBean.beanList)
  return _internal_beanlist();
}
inline const ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>&
SymbolLeverageBracketBean::_internal_beanlist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.beanlist_;
}
inline ::google::protobuf::RepeatedPtrField<::lampyris::crypto::protocol::trading::LeverageBracketBean>*
SymbolLeverageBracketBean::_internal_mutable_beanlist() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.beanlist_;
}

// -------------------------------------------------------------------

// LeverageBracketBean

// int32 leverage = 1;
inline void LeverageBracketBean::clear_leverage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leverage_ = 0;
}
inline ::int32_t LeverageBracketBean::leverage() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.LeverageBracketBean.leverage)
  return _internal_leverage();
}
inline void LeverageBracketBean::set_leverage(::int32_t value) {
  _internal_set_leverage(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.LeverageBracketBean.leverage)
}
inline ::int32_t LeverageBracketBean::_internal_leverage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.leverage_;
}
inline void LeverageBracketBean::_internal_set_leverage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.leverage_ = value;
}

// double notionalCap = 2;
inline void LeverageBracketBean::clear_notionalcap() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notionalcap_ = 0;
}
inline double LeverageBracketBean::notionalcap() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.LeverageBracketBean.notionalCap)
  return _internal_notionalcap();
}
inline void LeverageBracketBean::set_notionalcap(double value) {
  _internal_set_notionalcap(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.LeverageBracketBean.notionalCap)
}
inline double LeverageBracketBean::_internal_notionalcap() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notionalcap_;
}
inline void LeverageBracketBean::_internal_set_notionalcap(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notionalcap_ = value;
}

// double notionalFloor = 3;
inline void LeverageBracketBean::clear_notionalfloor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notionalfloor_ = 0;
}
inline double LeverageBracketBean::notionalfloor() const {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.trading.LeverageBracketBean.notionalFloor)
  return _internal_notionalfloor();
}
inline void LeverageBracketBean::set_notionalfloor(double value) {
  _internal_set_notionalfloor(value);
  // @@protoc_insertion_point(field_set:lampyris.crypto.protocol.trading.LeverageBracketBean.notionalFloor)
}
inline double LeverageBracketBean::_internal_notionalfloor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notionalfloor_;
}
inline void LeverageBracketBean::_internal_set_notionalfloor(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notionalfloor_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trading
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::lampyris::crypto::protocol::trading::OrderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::lampyris::crypto::protocol::trading::OrderType>() {
  return ::lampyris::crypto::protocol::trading::OrderType_descriptor();
}
template <>
struct is_proto_enum<::lampyris::crypto::protocol::trading::OrderStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::lampyris::crypto::protocol::trading::OrderStatus>() {
  return ::lampyris::crypto::protocol::trading::OrderStatus_descriptor();
}
template <>
struct is_proto_enum<::lampyris::crypto::protocol::trading::TimeInForceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::lampyris::crypto::protocol::trading::TimeInForceType>() {
  return ::lampyris::crypto::protocol::trading::TimeInForceType_descriptor();
}
template <>
struct is_proto_enum<::lampyris::crypto::protocol::trading::OrderSide> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::lampyris::crypto::protocol::trading::OrderSide>() {
  return ::lampyris::crypto::protocol::trading::OrderSide_descriptor();
}
template <>
struct is_proto_enum<::lampyris::crypto::protocol::trading::PositionSide> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::lampyris::crypto::protocol::trading::PositionSide>() {
  return ::lampyris::crypto::protocol::trading::PositionSide_descriptor();
}
template <>
struct is_proto_enum<::lampyris::crypto::protocol::trading::ConditionOrderTriggerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::lampyris::crypto::protocol::trading::ConditionOrderTriggerType>() {
  return ::lampyris::crypto::protocol::trading::ConditionOrderTriggerType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // trading_2eproto_2epb_2eh
