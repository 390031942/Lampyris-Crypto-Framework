// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 6.30.2

#ifndef common_2eproto_2epb_2eh
#define common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "account.pb.h"
#include "app.pb.h"
#include "quote.pb.h"
#include "strategy.pb.h"
#include "trading.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_common_2eproto;
}  // extern "C"
namespace lampyris {
namespace crypto {
namespace protocol {
namespace common {
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Request_class_data_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Response_class_data_;
}  // namespace common
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace lampyris {
namespace crypto {
namespace protocol {
namespace common {

// ===================================================================


// -------------------------------------------------------------------

class Request final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.common.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Request* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Request));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Request(::google::protobuf::internal::ConstantInitialized);

  inline Request(const Request& from) : Request(nullptr, from) {}
  inline Request(Request&& from) noexcept
      : Request(nullptr, std::move(from)) {}
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *reinterpret_cast<const Request*>(
        &_Request_default_instance_);
  }
  enum RequestTypeCase {
    kReqAccountSummaryUpdate = 1,
    kReqAccountAssetTransfer = 2,
    kReqQueryAssetTransferHistory = 3,
    kReqLogin = 4,
    kReqLogout = 5,
    kReqHeartBeat = 6,
    kReqUploadAppBehaviour = 7,
    kReqSubscribeTickerData = 8,
    kReqSubscribeTradeData = 9,
    kReqSubscribeCandlestickUpdate = 10,
    kReqCandlestickQuery = 11,
    kReqTradeRule = 12,
    kReqSelfSelectedSymbol = 13,
    kReqModifyStreategySetting = 14,
    kReqQueryStrategyExectionInfo = 15,
    kReqPlaceOrder = 16,
    kReqModifyOrder = 17,
    kReqCancelOrder = 18,
    kReqOneKeyClosePosition = 19,
    kReqQueryActiveOrders = 20,
    kReqQueryHistoricalOrders = 21,
    kReqQueryPositions = 22,
    kReqSetLeverage = 23,
    kReqQueryLeverage = 24,
    kReqQueryLeverageBracket = 25,
    REQUEST_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Request& a, Request& b) { a.Swap(&b); }
  inline void Swap(Request* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Request>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Request& from) { Request::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Request* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.common.Request"; }

 protected:
  explicit Request(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Request(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Request& from);
  Request(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Request&& from) noexcept
      : Request(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReqAccountSummaryUpdateFieldNumber = 1,
    kReqAccountAssetTransferFieldNumber = 2,
    kReqQueryAssetTransferHistoryFieldNumber = 3,
    kReqLoginFieldNumber = 4,
    kReqLogoutFieldNumber = 5,
    kReqHeartBeatFieldNumber = 6,
    kReqUploadAppBehaviourFieldNumber = 7,
    kReqSubscribeTickerDataFieldNumber = 8,
    kReqSubscribeTradeDataFieldNumber = 9,
    kReqSubscribeCandlestickUpdateFieldNumber = 10,
    kReqCandlestickQueryFieldNumber = 11,
    kReqTradeRuleFieldNumber = 12,
    kReqSelfSelectedSymbolFieldNumber = 13,
    kReqModifyStreategySettingFieldNumber = 14,
    kReqQueryStrategyExectionInfoFieldNumber = 15,
    kReqPlaceOrderFieldNumber = 16,
    kReqModifyOrderFieldNumber = 17,
    kReqCancelOrderFieldNumber = 18,
    kReqOneKeyClosePositionFieldNumber = 19,
    kReqQueryActiveOrdersFieldNumber = 20,
    kReqQueryHistoricalOrdersFieldNumber = 21,
    kReqQueryPositionsFieldNumber = 22,
    kReqSetLeverageFieldNumber = 23,
    kReqQueryLeverageFieldNumber = 24,
    kReqQueryLeverageBracketFieldNumber = 25,
  };
  // .lampyris.crypto.protocol.account.ReqAccountSummaryUpdate reqAccountSummaryUpdate = 1;
  bool has_reqaccountsummaryupdate() const;
  private:
  bool _internal_has_reqaccountsummaryupdate() const;

  public:
  void clear_reqaccountsummaryupdate() ;
  const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& reqaccountsummaryupdate() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE release_reqaccountsummaryupdate();
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NONNULL mutable_reqaccountsummaryupdate();
  void set_allocated_reqaccountsummaryupdate(::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqaccountsummaryupdate(::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE unsafe_arena_release_reqaccountsummaryupdate();

  private:
  const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& _internal_reqaccountsummaryupdate() const;
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NONNULL _internal_mutable_reqaccountsummaryupdate();

  public:
  // .lampyris.crypto.protocol.account.ReqAccountAssetTransfer reqAccountAssetTransfer = 2;
  bool has_reqaccountassettransfer() const;
  private:
  bool _internal_has_reqaccountassettransfer() const;

  public:
  void clear_reqaccountassettransfer() ;
  const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& reqaccountassettransfer() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE release_reqaccountassettransfer();
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NONNULL mutable_reqaccountassettransfer();
  void set_allocated_reqaccountassettransfer(::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqaccountassettransfer(::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE unsafe_arena_release_reqaccountassettransfer();

  private:
  const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& _internal_reqaccountassettransfer() const;
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NONNULL _internal_mutable_reqaccountassettransfer();

  public:
  // .lampyris.crypto.protocol.account.ReqQueryAssetTransferHistory reqQueryAssetTransferHistory = 3;
  bool has_reqqueryassettransferhistory() const;
  private:
  bool _internal_has_reqqueryassettransferhistory() const;

  public:
  void clear_reqqueryassettransferhistory() ;
  const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& reqqueryassettransferhistory() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE release_reqqueryassettransferhistory();
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NONNULL mutable_reqqueryassettransferhistory();
  void set_allocated_reqqueryassettransferhistory(::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqqueryassettransferhistory(::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE unsafe_arena_release_reqqueryassettransferhistory();

  private:
  const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& _internal_reqqueryassettransferhistory() const;
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NONNULL _internal_mutable_reqqueryassettransferhistory();

  public:
  // .lampyris.crypto.protocol.app.ReqLogin reqLogin = 4;
  bool has_reqlogin() const;
  private:
  bool _internal_has_reqlogin() const;

  public:
  void clear_reqlogin() ;
  const ::lampyris::crypto::protocol::app::ReqLogin& reqlogin() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE release_reqlogin();
  ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NONNULL mutable_reqlogin();
  void set_allocated_reqlogin(::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqlogin(::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE unsafe_arena_release_reqlogin();

  private:
  const ::lampyris::crypto::protocol::app::ReqLogin& _internal_reqlogin() const;
  ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NONNULL _internal_mutable_reqlogin();

  public:
  // .lampyris.crypto.protocol.app.ReqLogout reqLogout = 5;
  bool has_reqlogout() const;
  private:
  bool _internal_has_reqlogout() const;

  public:
  void clear_reqlogout() ;
  const ::lampyris::crypto::protocol::app::ReqLogout& reqlogout() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE release_reqlogout();
  ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NONNULL mutable_reqlogout();
  void set_allocated_reqlogout(::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqlogout(::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE unsafe_arena_release_reqlogout();

  private:
  const ::lampyris::crypto::protocol::app::ReqLogout& _internal_reqlogout() const;
  ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NONNULL _internal_mutable_reqlogout();

  public:
  // .lampyris.crypto.protocol.app.ReqHeartBeat reqHeartBeat = 6;
  bool has_reqheartbeat() const;
  private:
  bool _internal_has_reqheartbeat() const;

  public:
  void clear_reqheartbeat() ;
  const ::lampyris::crypto::protocol::app::ReqHeartBeat& reqheartbeat() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE release_reqheartbeat();
  ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NONNULL mutable_reqheartbeat();
  void set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqheartbeat(::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE unsafe_arena_release_reqheartbeat();

  private:
  const ::lampyris::crypto::protocol::app::ReqHeartBeat& _internal_reqheartbeat() const;
  ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NONNULL _internal_mutable_reqheartbeat();

  public:
  // .lampyris.crypto.protocol.app.ReqUploadAppBehaviour reqUploadAppBehaviour = 7;
  bool has_requploadappbehaviour() const;
  private:
  bool _internal_has_requploadappbehaviour() const;

  public:
  void clear_requploadappbehaviour() ;
  const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& requploadappbehaviour() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE release_requploadappbehaviour();
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NONNULL mutable_requploadappbehaviour();
  void set_allocated_requploadappbehaviour(::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_requploadappbehaviour(::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE unsafe_arena_release_requploadappbehaviour();

  private:
  const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& _internal_requploadappbehaviour() const;
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NONNULL _internal_mutable_requploadappbehaviour();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeTickerData reqSubscribeTickerData = 8;
  bool has_reqsubscribetickerdata() const;
  private:
  bool _internal_has_reqsubscribetickerdata() const;

  public:
  void clear_reqsubscribetickerdata() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& reqsubscribetickerdata() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE release_reqsubscribetickerdata();
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NONNULL mutable_reqsubscribetickerdata();
  void set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqsubscribetickerdata(::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE unsafe_arena_release_reqsubscribetickerdata();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& _internal_reqsubscribetickerdata() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NONNULL _internal_mutable_reqsubscribetickerdata();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeTradeData reqSubscribeTradeData = 9;
  bool has_reqsubscribetradedata() const;
  private:
  bool _internal_has_reqsubscribetradedata() const;

  public:
  void clear_reqsubscribetradedata() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& reqsubscribetradedata() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE release_reqsubscribetradedata();
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NONNULL mutable_reqsubscribetradedata();
  void set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqsubscribetradedata(::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE unsafe_arena_release_reqsubscribetradedata();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& _internal_reqsubscribetradedata() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NONNULL _internal_mutable_reqsubscribetradedata();

  public:
  // .lampyris.crypto.protocol.quote.ReqSubscribeCandlestickUpdate reqSubscribeCandlestickUpdate = 10;
  bool has_reqsubscribecandlestickupdate() const;
  private:
  bool _internal_has_reqsubscribecandlestickupdate() const;

  public:
  void clear_reqsubscribecandlestickupdate() ;
  const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& reqsubscribecandlestickupdate() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE release_reqsubscribecandlestickupdate();
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NONNULL mutable_reqsubscribecandlestickupdate();
  void set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqsubscribecandlestickupdate(::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE unsafe_arena_release_reqsubscribecandlestickupdate();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& _internal_reqsubscribecandlestickupdate() const;
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NONNULL _internal_mutable_reqsubscribecandlestickupdate();

  public:
  // .lampyris.crypto.protocol.quote.ReqCandlestickQuery reqCandlestickQuery = 11;
  bool has_reqcandlestickquery() const;
  private:
  bool _internal_has_reqcandlestickquery() const;

  public:
  void clear_reqcandlestickquery() ;
  const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& reqcandlestickquery() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE release_reqcandlestickquery();
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NONNULL mutable_reqcandlestickquery();
  void set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqcandlestickquery(::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE unsafe_arena_release_reqcandlestickquery();

  private:
  const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& _internal_reqcandlestickquery() const;
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NONNULL _internal_mutable_reqcandlestickquery();

  public:
  // .lampyris.crypto.protocol.quote.ReqTradeRule reqTradeRule = 12;
  bool has_reqtraderule() const;
  private:
  bool _internal_has_reqtraderule() const;

  public:
  void clear_reqtraderule() ;
  const ::lampyris::crypto::protocol::quote::ReqTradeRule& reqtraderule() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE release_reqtraderule();
  ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NONNULL mutable_reqtraderule();
  void set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqtraderule(::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE unsafe_arena_release_reqtraderule();

  private:
  const ::lampyris::crypto::protocol::quote::ReqTradeRule& _internal_reqtraderule() const;
  ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NONNULL _internal_mutable_reqtraderule();

  public:
  // .lampyris.crypto.protocol.quote.ReqSelfSelectedSymbol reqSelfSelectedSymbol = 13;
  bool has_reqselfselectedsymbol() const;
  private:
  bool _internal_has_reqselfselectedsymbol() const;

  public:
  void clear_reqselfselectedsymbol() ;
  const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& reqselfselectedsymbol() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE release_reqselfselectedsymbol();
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NONNULL mutable_reqselfselectedsymbol();
  void set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqselfselectedsymbol(::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE unsafe_arena_release_reqselfselectedsymbol();

  private:
  const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& _internal_reqselfselectedsymbol() const;
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NONNULL _internal_mutable_reqselfselectedsymbol();

  public:
  // .lampyris.crypto.protocol.strategy.ReqModifyStreategySetting reqModifyStreategySetting = 14;
  bool has_reqmodifystreategysetting() const;
  private:
  bool _internal_has_reqmodifystreategysetting() const;

  public:
  void clear_reqmodifystreategysetting() ;
  const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& reqmodifystreategysetting() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE release_reqmodifystreategysetting();
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NONNULL mutable_reqmodifystreategysetting();
  void set_allocated_reqmodifystreategysetting(::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqmodifystreategysetting(::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE unsafe_arena_release_reqmodifystreategysetting();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& _internal_reqmodifystreategysetting() const;
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NONNULL _internal_mutable_reqmodifystreategysetting();

  public:
  // .lampyris.crypto.protocol.strategy.ReqQueryStrategyExectionInfo reqQueryStrategyExectionInfo = 15;
  bool has_reqquerystrategyexectioninfo() const;
  private:
  bool _internal_has_reqquerystrategyexectioninfo() const;

  public:
  void clear_reqquerystrategyexectioninfo() ;
  const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& reqquerystrategyexectioninfo() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE release_reqquerystrategyexectioninfo();
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NONNULL mutable_reqquerystrategyexectioninfo();
  void set_allocated_reqquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE unsafe_arena_release_reqquerystrategyexectioninfo();

  private:
  const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& _internal_reqquerystrategyexectioninfo() const;
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NONNULL _internal_mutable_reqquerystrategyexectioninfo();

  public:
  // .lampyris.crypto.protocol.trading.ReqPlaceOrder reqPlaceOrder = 16;
  bool has_reqplaceorder() const;
  private:
  bool _internal_has_reqplaceorder() const;

  public:
  void clear_reqplaceorder() ;
  const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& reqplaceorder() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE release_reqplaceorder();
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NONNULL mutable_reqplaceorder();
  void set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqplaceorder(::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE unsafe_arena_release_reqplaceorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& _internal_reqplaceorder() const;
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NONNULL _internal_mutable_reqplaceorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqModifyOrder reqModifyOrder = 17;
  bool has_reqmodifyorder() const;
  private:
  bool _internal_has_reqmodifyorder() const;

  public:
  void clear_reqmodifyorder() ;
  const ::lampyris::crypto::protocol::trading::ReqModifyOrder& reqmodifyorder() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE release_reqmodifyorder();
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NONNULL mutable_reqmodifyorder();
  void set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqmodifyorder(::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE unsafe_arena_release_reqmodifyorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqModifyOrder& _internal_reqmodifyorder() const;
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NONNULL _internal_mutable_reqmodifyorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqCancelOrder reqCancelOrder = 18;
  bool has_reqcancelorder() const;
  private:
  bool _internal_has_reqcancelorder() const;

  public:
  void clear_reqcancelorder() ;
  const ::lampyris::crypto::protocol::trading::ReqCancelOrder& reqcancelorder() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE release_reqcancelorder();
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NONNULL mutable_reqcancelorder();
  void set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqcancelorder(::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE unsafe_arena_release_reqcancelorder();

  private:
  const ::lampyris::crypto::protocol::trading::ReqCancelOrder& _internal_reqcancelorder() const;
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NONNULL _internal_mutable_reqcancelorder();

  public:
  // .lampyris.crypto.protocol.trading.ReqOneKeyClosePosition reqOneKeyClosePosition = 19;
  bool has_reqonekeycloseposition() const;
  private:
  bool _internal_has_reqonekeycloseposition() const;

  public:
  void clear_reqonekeycloseposition() ;
  const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& reqonekeycloseposition() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE release_reqonekeycloseposition();
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NONNULL mutable_reqonekeycloseposition();
  void set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqonekeycloseposition(::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE unsafe_arena_release_reqonekeycloseposition();

  private:
  const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& _internal_reqonekeycloseposition() const;
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NONNULL _internal_mutable_reqonekeycloseposition();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryActiveOrders reqQueryActiveOrders = 20;
  bool has_reqqueryactiveorders() const;
  private:
  bool _internal_has_reqqueryactiveorders() const;

  public:
  void clear_reqqueryactiveorders() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& reqqueryactiveorders() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE release_reqqueryactiveorders();
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NONNULL mutable_reqqueryactiveorders();
  void set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqqueryactiveorders(::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE unsafe_arena_release_reqqueryactiveorders();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& _internal_reqqueryactiveorders() const;
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NONNULL _internal_mutable_reqqueryactiveorders();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders reqQueryHistoricalOrders = 21;
  bool has_reqqueryhistoricalorders() const;
  private:
  bool _internal_has_reqqueryhistoricalorders() const;

  public:
  void clear_reqqueryhistoricalorders() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& reqqueryhistoricalorders() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE release_reqqueryhistoricalorders();
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NONNULL mutable_reqqueryhistoricalorders();
  void set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqqueryhistoricalorders(::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE unsafe_arena_release_reqqueryhistoricalorders();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& _internal_reqqueryhistoricalorders() const;
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NONNULL _internal_mutable_reqqueryhistoricalorders();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryPositions reqQueryPositions = 22;
  bool has_reqquerypositions() const;
  private:
  bool _internal_has_reqquerypositions() const;

  public:
  void clear_reqquerypositions() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryPositions& reqquerypositions() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE release_reqquerypositions();
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NONNULL mutable_reqquerypositions();
  void set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqquerypositions(::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE unsafe_arena_release_reqquerypositions();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryPositions& _internal_reqquerypositions() const;
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NONNULL _internal_mutable_reqquerypositions();

  public:
  // .lampyris.crypto.protocol.trading.ReqSetLeverage reqSetLeverage = 23;
  bool has_reqsetleverage() const;
  private:
  bool _internal_has_reqsetleverage() const;

  public:
  void clear_reqsetleverage() ;
  const ::lampyris::crypto::protocol::trading::ReqSetLeverage& reqsetleverage() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE release_reqsetleverage();
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NONNULL mutable_reqsetleverage();
  void set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqsetleverage(::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE unsafe_arena_release_reqsetleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ReqSetLeverage& _internal_reqsetleverage() const;
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NONNULL _internal_mutable_reqsetleverage();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryLeverage reqQueryLeverage = 24;
  bool has_reqqueryleverage() const;
  private:
  bool _internal_has_reqqueryleverage() const;

  public:
  void clear_reqqueryleverage() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& reqqueryleverage() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE release_reqqueryleverage();
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NONNULL mutable_reqqueryleverage();
  void set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqqueryleverage(::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE unsafe_arena_release_reqqueryleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& _internal_reqqueryleverage() const;
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NONNULL _internal_mutable_reqqueryleverage();

  public:
  // .lampyris.crypto.protocol.trading.ReqQueryLeverageBracket reqQueryLeverageBracket = 25;
  bool has_reqqueryleveragebracket() const;
  private:
  bool _internal_has_reqqueryleveragebracket() const;

  public:
  void clear_reqqueryleveragebracket() ;
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& reqqueryleveragebracket() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE release_reqqueryleveragebracket();
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NONNULL mutable_reqqueryleveragebracket();
  void set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reqqueryleveragebracket(::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE unsafe_arena_release_reqqueryleveragebracket();

  private:
  const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& _internal_reqqueryleveragebracket() const;
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NONNULL _internal_mutable_reqqueryleveragebracket();

  public:
  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.common.Request)
 private:
  class _Internal;
  void set_has_reqaccountsummaryupdate();
  void set_has_reqaccountassettransfer();
  void set_has_reqqueryassettransferhistory();
  void set_has_reqlogin();
  void set_has_reqlogout();
  void set_has_reqheartbeat();
  void set_has_requploadappbehaviour();
  void set_has_reqsubscribetickerdata();
  void set_has_reqsubscribetradedata();
  void set_has_reqsubscribecandlestickupdate();
  void set_has_reqcandlestickquery();
  void set_has_reqtraderule();
  void set_has_reqselfselectedsymbol();
  void set_has_reqmodifystreategysetting();
  void set_has_reqquerystrategyexectioninfo();
  void set_has_reqplaceorder();
  void set_has_reqmodifyorder();
  void set_has_reqcancelorder();
  void set_has_reqonekeycloseposition();
  void set_has_reqqueryactiveorders();
  void set_has_reqqueryhistoricalorders();
  void set_has_reqquerypositions();
  void set_has_reqsetleverage();
  void set_has_reqqueryleverage();
  void set_has_reqqueryleveragebracket();
  inline bool has_request_type() const;
  inline void clear_has_request_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 25,
                                   25, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Request& from_msg);
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqaccountsummaryupdate_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqaccountassettransfer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqqueryassettransferhistory_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqlogin_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqlogout_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqheartbeat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE requploadappbehaviour_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqsubscribetickerdata_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqsubscribetradedata_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqsubscribecandlestickupdate_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqcandlestickquery_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqtraderule_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqselfselectedsymbol_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqmodifystreategysetting_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqquerystrategyexectioninfo_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqplaceorder_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqmodifyorder_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqcancelorder_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqonekeycloseposition_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqqueryactiveorders_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqqueryhistoricalorders_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqquerypositions_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqsetleverage_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqqueryleverage_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reqqueryleveragebracket_;
    } request_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Request_class_data_;
// -------------------------------------------------------------------

class Response final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lampyris.crypto.protocol.common.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Response* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Response));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response(::google::protobuf::internal::ConstantInitialized);

  inline Response(const Response& from) : Response(nullptr, from) {}
  inline Response(Response&& from) noexcept
      : Response(nullptr, std::move(from)) {}
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *reinterpret_cast<const Response*>(
        &_Response_default_instance_);
  }
  enum ResponseTypeCase {
    kAccountAssetInfoBean = 1,
    kSubAccountInfoBean = 2,
    kResQuerySubAcccountList = 3,
    kResAccountSummaryUpdate = 4,
    kAssetTransferHistoryInfoDetailBean = 5,
    kAssetTransferHistoryInfoBean = 6,
    kResLogin = 7,
    kResHeartBeat = 8,
    kResNotice = 9,
    kSymbolTickerDataBean = 10,
    kResSubscribeTickerData = 11,
    kSymbolTradeDataBean = 12,
    kTradeDataBean = 13,
    kResCandlestickQuery = 14,
    kCandlestickUpdateBean = 15,
    kCandlestickBean = 16,
    kResTradeRule = 17,
    kSymbolTradeRuleBean = 18,
    kMarketMonitorNoticeListBean = 19,
    kMarketMonitorNoticeBean = 20,
    kSelfSelectedSymbolInfoBean = 21,
    kSelfSelectedSymbolGroupBean = 22,
    kResSelfSelectedSymbol = 23,
    kMarketPreviewIntervalDataBean = 24,
    kResMarketPreviewData = 25,
    kStreategyConfigBean = 26,
    kStreategyFieldBean = 27,
    kResModifyStreategySetting = 28,
    kResStreategySettings = 29,
    kStrategyExectionInfoBean = 30,
    kResQueryStrategyExectionInfo = 31,
    kConditionTriggerBean = 32,
    kOrderBean = 33,
    kOrderStatusBean = 34,
    kResQueryOrders = 35,
    kPositionBean = 36,
    kResQueryPositions = 37,
    kLeverageBean = 38,
    kResQueryLeverage = 39,
    kResQueryLeverageBracket = 40,
    kSymbolLeverageBracketBean = 41,
    kLeverageBracketBean = 42,
    RESPONSE_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Response& a, Response& b) { a.Swap(&b); }
  inline void Swap(Response* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Response& from) { Response::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Response* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "lampyris.crypto.protocol.common.Response"; }

 protected:
  explicit Response(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Response(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Response& from);
  Response(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Response&& from) noexcept
      : Response(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountAssetInfoBeanFieldNumber = 1,
    kSubAccountInfoBeanFieldNumber = 2,
    kResQuerySubAcccountListFieldNumber = 3,
    kResAccountSummaryUpdateFieldNumber = 4,
    kAssetTransferHistoryInfoDetailBeanFieldNumber = 5,
    kAssetTransferHistoryInfoBeanFieldNumber = 6,
    kResLoginFieldNumber = 7,
    kResHeartBeatFieldNumber = 8,
    kResNoticeFieldNumber = 9,
    kSymbolTickerDataBeanFieldNumber = 10,
    kResSubscribeTickerDataFieldNumber = 11,
    kSymbolTradeDataBeanFieldNumber = 12,
    kTradeDataBeanFieldNumber = 13,
    kResCandlestickQueryFieldNumber = 14,
    kCandlestickUpdateBeanFieldNumber = 15,
    kCandlestickBeanFieldNumber = 16,
    kResTradeRuleFieldNumber = 17,
    kSymbolTradeRuleBeanFieldNumber = 18,
    kMarketMonitorNoticeListBeanFieldNumber = 19,
    kMarketMonitorNoticeBeanFieldNumber = 20,
    kSelfSelectedSymbolInfoBeanFieldNumber = 21,
    kSelfSelectedSymbolGroupBeanFieldNumber = 22,
    kResSelfSelectedSymbolFieldNumber = 23,
    kMarketPreviewIntervalDataBeanFieldNumber = 24,
    kResMarketPreviewDataFieldNumber = 25,
    kStreategyConfigBeanFieldNumber = 26,
    kStreategyFieldBeanFieldNumber = 27,
    kResModifyStreategySettingFieldNumber = 28,
    kResStreategySettingsFieldNumber = 29,
    kStrategyExectionInfoBeanFieldNumber = 30,
    kResQueryStrategyExectionInfoFieldNumber = 31,
    kConditionTriggerBeanFieldNumber = 32,
    kOrderBeanFieldNumber = 33,
    kOrderStatusBeanFieldNumber = 34,
    kResQueryOrdersFieldNumber = 35,
    kPositionBeanFieldNumber = 36,
    kResQueryPositionsFieldNumber = 37,
    kLeverageBeanFieldNumber = 38,
    kResQueryLeverageFieldNumber = 39,
    kResQueryLeverageBracketFieldNumber = 40,
    kSymbolLeverageBracketBeanFieldNumber = 41,
    kLeverageBracketBeanFieldNumber = 42,
  };
  // .lampyris.crypto.protocol.account.AccountAssetInfoBean accountAssetInfoBean = 1;
  bool has_accountassetinfobean() const;
  private:
  bool _internal_has_accountassetinfobean() const;

  public:
  void clear_accountassetinfobean() ;
  const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& accountassetinfobean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE release_accountassetinfobean();
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NONNULL mutable_accountassetinfobean();
  void set_allocated_accountassetinfobean(::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_accountassetinfobean(::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE unsafe_arena_release_accountassetinfobean();

  private:
  const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& _internal_accountassetinfobean() const;
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NONNULL _internal_mutable_accountassetinfobean();

  public:
  // .lampyris.crypto.protocol.account.SubAccountInfoBean subAccountInfoBean = 2;
  bool has_subaccountinfobean() const;
  private:
  bool _internal_has_subaccountinfobean() const;

  public:
  void clear_subaccountinfobean() ;
  const ::lampyris::crypto::protocol::account::SubAccountInfoBean& subaccountinfobean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE release_subaccountinfobean();
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NONNULL mutable_subaccountinfobean();
  void set_allocated_subaccountinfobean(::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subaccountinfobean(::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE unsafe_arena_release_subaccountinfobean();

  private:
  const ::lampyris::crypto::protocol::account::SubAccountInfoBean& _internal_subaccountinfobean() const;
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NONNULL _internal_mutable_subaccountinfobean();

  public:
  // .lampyris.crypto.protocol.account.ResQuerySubAcccountList resQuerySubAcccountList = 3;
  bool has_resquerysubacccountlist() const;
  private:
  bool _internal_has_resquerysubacccountlist() const;

  public:
  void clear_resquerysubacccountlist() ;
  const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& resquerysubacccountlist() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE release_resquerysubacccountlist();
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NONNULL mutable_resquerysubacccountlist();
  void set_allocated_resquerysubacccountlist(::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resquerysubacccountlist(::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE unsafe_arena_release_resquerysubacccountlist();

  private:
  const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& _internal_resquerysubacccountlist() const;
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NONNULL _internal_mutable_resquerysubacccountlist();

  public:
  // .lampyris.crypto.protocol.account.ResAccountSummaryUpdate resAccountSummaryUpdate = 4;
  bool has_resaccountsummaryupdate() const;
  private:
  bool _internal_has_resaccountsummaryupdate() const;

  public:
  void clear_resaccountsummaryupdate() ;
  const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& resaccountsummaryupdate() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE release_resaccountsummaryupdate();
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NONNULL mutable_resaccountsummaryupdate();
  void set_allocated_resaccountsummaryupdate(::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resaccountsummaryupdate(::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE unsafe_arena_release_resaccountsummaryupdate();

  private:
  const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& _internal_resaccountsummaryupdate() const;
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NONNULL _internal_mutable_resaccountsummaryupdate();

  public:
  // .lampyris.crypto.protocol.account.AssetTransferHistoryInfoDetailBean assetTransferHistoryInfoDetailBean = 5;
  bool has_assettransferhistoryinfodetailbean() const;
  private:
  bool _internal_has_assettransferhistoryinfodetailbean() const;

  public:
  void clear_assettransferhistoryinfodetailbean() ;
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& assettransferhistoryinfodetailbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE release_assettransferhistoryinfodetailbean();
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NONNULL mutable_assettransferhistoryinfodetailbean();
  void set_allocated_assettransferhistoryinfodetailbean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_assettransferhistoryinfodetailbean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE unsafe_arena_release_assettransferhistoryinfodetailbean();

  private:
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& _internal_assettransferhistoryinfodetailbean() const;
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NONNULL _internal_mutable_assettransferhistoryinfodetailbean();

  public:
  // .lampyris.crypto.protocol.account.AssetTransferHistoryInfoBean assetTransferHistoryInfoBean = 6;
  bool has_assettransferhistoryinfobean() const;
  private:
  bool _internal_has_assettransferhistoryinfobean() const;

  public:
  void clear_assettransferhistoryinfobean() ;
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& assettransferhistoryinfobean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE release_assettransferhistoryinfobean();
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NONNULL mutable_assettransferhistoryinfobean();
  void set_allocated_assettransferhistoryinfobean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_assettransferhistoryinfobean(::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE unsafe_arena_release_assettransferhistoryinfobean();

  private:
  const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& _internal_assettransferhistoryinfobean() const;
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NONNULL _internal_mutable_assettransferhistoryinfobean();

  public:
  // .lampyris.crypto.protocol.app.ResLogin resLogin = 7;
  bool has_reslogin() const;
  private:
  bool _internal_has_reslogin() const;

  public:
  void clear_reslogin() ;
  const ::lampyris::crypto::protocol::app::ResLogin& reslogin() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE release_reslogin();
  ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NONNULL mutable_reslogin();
  void set_allocated_reslogin(::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reslogin(::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE unsafe_arena_release_reslogin();

  private:
  const ::lampyris::crypto::protocol::app::ResLogin& _internal_reslogin() const;
  ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NONNULL _internal_mutable_reslogin();

  public:
  // .lampyris.crypto.protocol.app.ResHeartBeat resHeartBeat = 8;
  bool has_resheartbeat() const;
  private:
  bool _internal_has_resheartbeat() const;

  public:
  void clear_resheartbeat() ;
  const ::lampyris::crypto::protocol::app::ResHeartBeat& resheartbeat() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE release_resheartbeat();
  ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NONNULL mutable_resheartbeat();
  void set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resheartbeat(::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE unsafe_arena_release_resheartbeat();

  private:
  const ::lampyris::crypto::protocol::app::ResHeartBeat& _internal_resheartbeat() const;
  ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NONNULL _internal_mutable_resheartbeat();

  public:
  // .lampyris.crypto.protocol.app.ResNotice resNotice = 9;
  bool has_resnotice() const;
  private:
  bool _internal_has_resnotice() const;

  public:
  void clear_resnotice() ;
  const ::lampyris::crypto::protocol::app::ResNotice& resnotice() const;
  [[nodiscard]] ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE release_resnotice();
  ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NONNULL mutable_resnotice();
  void set_allocated_resnotice(::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resnotice(::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE unsafe_arena_release_resnotice();

  private:
  const ::lampyris::crypto::protocol::app::ResNotice& _internal_resnotice() const;
  ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NONNULL _internal_mutable_resnotice();

  public:
  // .lampyris.crypto.protocol.quote.SymbolTickerDataBean symbolTickerDataBean = 10;
  bool has_symboltickerdatabean() const;
  private:
  bool _internal_has_symboltickerdatabean() const;

  public:
  void clear_symboltickerdatabean() ;
  const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& symboltickerdatabean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE release_symboltickerdatabean();
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NONNULL mutable_symboltickerdatabean();
  void set_allocated_symboltickerdatabean(::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_symboltickerdatabean(::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE unsafe_arena_release_symboltickerdatabean();

  private:
  const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& _internal_symboltickerdatabean() const;
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NONNULL _internal_mutable_symboltickerdatabean();

  public:
  // .lampyris.crypto.protocol.quote.ResSubscribeTickerData resSubscribeTickerData = 11;
  bool has_ressubscribetickerdata() const;
  private:
  bool _internal_has_ressubscribetickerdata() const;

  public:
  void clear_ressubscribetickerdata() ;
  const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& ressubscribetickerdata() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE release_ressubscribetickerdata();
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NONNULL mutable_ressubscribetickerdata();
  void set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ressubscribetickerdata(::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE unsafe_arena_release_ressubscribetickerdata();

  private:
  const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& _internal_ressubscribetickerdata() const;
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NONNULL _internal_mutable_ressubscribetickerdata();

  public:
  // .lampyris.crypto.protocol.quote.SymbolTradeDataBean symbolTradeDataBean = 12;
  bool has_symboltradedatabean() const;
  private:
  bool _internal_has_symboltradedatabean() const;

  public:
  void clear_symboltradedatabean() ;
  const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& symboltradedatabean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE release_symboltradedatabean();
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NONNULL mutable_symboltradedatabean();
  void set_allocated_symboltradedatabean(::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_symboltradedatabean(::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE unsafe_arena_release_symboltradedatabean();

  private:
  const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& _internal_symboltradedatabean() const;
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NONNULL _internal_mutable_symboltradedatabean();

  public:
  // .lampyris.crypto.protocol.quote.TradeDataBean tradeDataBean = 13;
  bool has_tradedatabean() const;
  private:
  bool _internal_has_tradedatabean() const;

  public:
  void clear_tradedatabean() ;
  const ::lampyris::crypto::protocol::quote::TradeDataBean& tradedatabean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE release_tradedatabean();
  ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NONNULL mutable_tradedatabean();
  void set_allocated_tradedatabean(::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tradedatabean(::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE unsafe_arena_release_tradedatabean();

  private:
  const ::lampyris::crypto::protocol::quote::TradeDataBean& _internal_tradedatabean() const;
  ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NONNULL _internal_mutable_tradedatabean();

  public:
  // .lampyris.crypto.protocol.quote.ResCandlestickQuery resCandlestickQuery = 14;
  bool has_rescandlestickquery() const;
  private:
  bool _internal_has_rescandlestickquery() const;

  public:
  void clear_rescandlestickquery() ;
  const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& rescandlestickquery() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE release_rescandlestickquery();
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NONNULL mutable_rescandlestickquery();
  void set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rescandlestickquery(::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE unsafe_arena_release_rescandlestickquery();

  private:
  const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& _internal_rescandlestickquery() const;
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NONNULL _internal_mutable_rescandlestickquery();

  public:
  // .lampyris.crypto.protocol.quote.CandlestickUpdateBean candlestickUpdateBean = 15;
  bool has_candlestickupdatebean() const;
  private:
  bool _internal_has_candlestickupdatebean() const;

  public:
  void clear_candlestickupdatebean() ;
  const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& candlestickupdatebean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE release_candlestickupdatebean();
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NONNULL mutable_candlestickupdatebean();
  void set_allocated_candlestickupdatebean(::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_candlestickupdatebean(::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE unsafe_arena_release_candlestickupdatebean();

  private:
  const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& _internal_candlestickupdatebean() const;
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NONNULL _internal_mutable_candlestickupdatebean();

  public:
  // .lampyris.crypto.protocol.quote.CandlestickBean candlestickBean = 16;
  bool has_candlestickbean() const;
  private:
  bool _internal_has_candlestickbean() const;

  public:
  void clear_candlestickbean() ;
  const ::lampyris::crypto::protocol::quote::CandlestickBean& candlestickbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE release_candlestickbean();
  ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NONNULL mutable_candlestickbean();
  void set_allocated_candlestickbean(::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_candlestickbean(::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE unsafe_arena_release_candlestickbean();

  private:
  const ::lampyris::crypto::protocol::quote::CandlestickBean& _internal_candlestickbean() const;
  ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NONNULL _internal_mutable_candlestickbean();

  public:
  // .lampyris.crypto.protocol.quote.ResTradeRule resTradeRule = 17;
  bool has_restraderule() const;
  private:
  bool _internal_has_restraderule() const;

  public:
  void clear_restraderule() ;
  const ::lampyris::crypto::protocol::quote::ResTradeRule& restraderule() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE release_restraderule();
  ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NONNULL mutable_restraderule();
  void set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_restraderule(::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE unsafe_arena_release_restraderule();

  private:
  const ::lampyris::crypto::protocol::quote::ResTradeRule& _internal_restraderule() const;
  ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NONNULL _internal_mutable_restraderule();

  public:
  // .lampyris.crypto.protocol.quote.SymbolTradeRuleBean symbolTradeRuleBean = 18;
  bool has_symboltraderulebean() const;
  private:
  bool _internal_has_symboltraderulebean() const;

  public:
  void clear_symboltraderulebean() ;
  const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& symboltraderulebean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE release_symboltraderulebean();
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NONNULL mutable_symboltraderulebean();
  void set_allocated_symboltraderulebean(::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_symboltraderulebean(::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE unsafe_arena_release_symboltraderulebean();

  private:
  const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& _internal_symboltraderulebean() const;
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NONNULL _internal_mutable_symboltraderulebean();

  public:
  // .lampyris.crypto.protocol.quote.MarketMonitorNoticeListBean marketMonitorNoticeListBean = 19;
  bool has_marketmonitornoticelistbean() const;
  private:
  bool _internal_has_marketmonitornoticelistbean() const;

  public:
  void clear_marketmonitornoticelistbean() ;
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& marketmonitornoticelistbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE release_marketmonitornoticelistbean();
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NONNULL mutable_marketmonitornoticelistbean();
  void set_allocated_marketmonitornoticelistbean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_marketmonitornoticelistbean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE unsafe_arena_release_marketmonitornoticelistbean();

  private:
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& _internal_marketmonitornoticelistbean() const;
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NONNULL _internal_mutable_marketmonitornoticelistbean();

  public:
  // .lampyris.crypto.protocol.quote.MarketMonitorNoticeBean marketMonitorNoticeBean = 20;
  bool has_marketmonitornoticebean() const;
  private:
  bool _internal_has_marketmonitornoticebean() const;

  public:
  void clear_marketmonitornoticebean() ;
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& marketmonitornoticebean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE release_marketmonitornoticebean();
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NONNULL mutable_marketmonitornoticebean();
  void set_allocated_marketmonitornoticebean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_marketmonitornoticebean(::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE unsafe_arena_release_marketmonitornoticebean();

  private:
  const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& _internal_marketmonitornoticebean() const;
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NONNULL _internal_mutable_marketmonitornoticebean();

  public:
  // .lampyris.crypto.protocol.quote.SelfSelectedSymbolInfoBean selfSelectedSymbolInfoBean = 21;
  bool has_selfselectedsymbolinfobean() const;
  private:
  bool _internal_has_selfselectedsymbolinfobean() const;

  public:
  void clear_selfselectedsymbolinfobean() ;
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& selfselectedsymbolinfobean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE release_selfselectedsymbolinfobean();
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NONNULL mutable_selfselectedsymbolinfobean();
  void set_allocated_selfselectedsymbolinfobean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_selfselectedsymbolinfobean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE unsafe_arena_release_selfselectedsymbolinfobean();

  private:
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& _internal_selfselectedsymbolinfobean() const;
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NONNULL _internal_mutable_selfselectedsymbolinfobean();

  public:
  // .lampyris.crypto.protocol.quote.SelfSelectedSymbolGroupBean selfSelectedSymbolGroupBean = 22;
  bool has_selfselectedsymbolgroupbean() const;
  private:
  bool _internal_has_selfselectedsymbolgroupbean() const;

  public:
  void clear_selfselectedsymbolgroupbean() ;
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& selfselectedsymbolgroupbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE release_selfselectedsymbolgroupbean();
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NONNULL mutable_selfselectedsymbolgroupbean();
  void set_allocated_selfselectedsymbolgroupbean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_selfselectedsymbolgroupbean(::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE unsafe_arena_release_selfselectedsymbolgroupbean();

  private:
  const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& _internal_selfselectedsymbolgroupbean() const;
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NONNULL _internal_mutable_selfselectedsymbolgroupbean();

  public:
  // .lampyris.crypto.protocol.quote.ResSelfSelectedSymbol resSelfSelectedSymbol = 23;
  bool has_resselfselectedsymbol() const;
  private:
  bool _internal_has_resselfselectedsymbol() const;

  public:
  void clear_resselfselectedsymbol() ;
  const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& resselfselectedsymbol() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE release_resselfselectedsymbol();
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NONNULL mutable_resselfselectedsymbol();
  void set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resselfselectedsymbol(::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE unsafe_arena_release_resselfselectedsymbol();

  private:
  const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& _internal_resselfselectedsymbol() const;
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NONNULL _internal_mutable_resselfselectedsymbol();

  public:
  // .lampyris.crypto.protocol.quote.MarketPreviewIntervalDataBean marketPreviewIntervalDataBean = 24;
  bool has_marketpreviewintervaldatabean() const;
  private:
  bool _internal_has_marketpreviewintervaldatabean() const;

  public:
  void clear_marketpreviewintervaldatabean() ;
  const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& marketpreviewintervaldatabean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE release_marketpreviewintervaldatabean();
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NONNULL mutable_marketpreviewintervaldatabean();
  void set_allocated_marketpreviewintervaldatabean(::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_marketpreviewintervaldatabean(::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE unsafe_arena_release_marketpreviewintervaldatabean();

  private:
  const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& _internal_marketpreviewintervaldatabean() const;
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NONNULL _internal_mutable_marketpreviewintervaldatabean();

  public:
  // .lampyris.crypto.protocol.quote.ResMarketPreviewData resMarketPreviewData = 25;
  bool has_resmarketpreviewdata() const;
  private:
  bool _internal_has_resmarketpreviewdata() const;

  public:
  void clear_resmarketpreviewdata() ;
  const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& resmarketpreviewdata() const;
  [[nodiscard]] ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE release_resmarketpreviewdata();
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NONNULL mutable_resmarketpreviewdata();
  void set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resmarketpreviewdata(::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE unsafe_arena_release_resmarketpreviewdata();

  private:
  const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& _internal_resmarketpreviewdata() const;
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NONNULL _internal_mutable_resmarketpreviewdata();

  public:
  // .lampyris.crypto.protocol.strategy.StreategyConfigBean streategyConfigBean = 26;
  bool has_streategyconfigbean() const;
  private:
  bool _internal_has_streategyconfigbean() const;

  public:
  void clear_streategyconfigbean() ;
  const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& streategyconfigbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE release_streategyconfigbean();
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NONNULL mutable_streategyconfigbean();
  void set_allocated_streategyconfigbean(::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_streategyconfigbean(::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE unsafe_arena_release_streategyconfigbean();

  private:
  const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& _internal_streategyconfigbean() const;
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NONNULL _internal_mutable_streategyconfigbean();

  public:
  // .lampyris.crypto.protocol.strategy.StreategyFieldBean streategyFieldBean = 27;
  bool has_streategyfieldbean() const;
  private:
  bool _internal_has_streategyfieldbean() const;

  public:
  void clear_streategyfieldbean() ;
  const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& streategyfieldbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE release_streategyfieldbean();
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NONNULL mutable_streategyfieldbean();
  void set_allocated_streategyfieldbean(::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_streategyfieldbean(::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE unsafe_arena_release_streategyfieldbean();

  private:
  const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& _internal_streategyfieldbean() const;
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NONNULL _internal_mutable_streategyfieldbean();

  public:
  // .lampyris.crypto.protocol.strategy.ResModifyStreategySetting resModifyStreategySetting = 28;
  bool has_resmodifystreategysetting() const;
  private:
  bool _internal_has_resmodifystreategysetting() const;

  public:
  void clear_resmodifystreategysetting() ;
  const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& resmodifystreategysetting() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE release_resmodifystreategysetting();
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NONNULL mutable_resmodifystreategysetting();
  void set_allocated_resmodifystreategysetting(::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resmodifystreategysetting(::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE unsafe_arena_release_resmodifystreategysetting();

  private:
  const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& _internal_resmodifystreategysetting() const;
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NONNULL _internal_mutable_resmodifystreategysetting();

  public:
  // .lampyris.crypto.protocol.strategy.ResStreategySettings resStreategySettings = 29;
  bool has_resstreategysettings() const;
  private:
  bool _internal_has_resstreategysettings() const;

  public:
  void clear_resstreategysettings() ;
  const ::lampyris::crypto::protocol::strategy::ResStreategySettings& resstreategysettings() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE release_resstreategysettings();
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NONNULL mutable_resstreategysettings();
  void set_allocated_resstreategysettings(::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resstreategysettings(::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE unsafe_arena_release_resstreategysettings();

  private:
  const ::lampyris::crypto::protocol::strategy::ResStreategySettings& _internal_resstreategysettings() const;
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NONNULL _internal_mutable_resstreategysettings();

  public:
  // .lampyris.crypto.protocol.strategy.StrategyExectionInfoBean strategyExectionInfoBean = 30;
  bool has_strategyexectioninfobean() const;
  private:
  bool _internal_has_strategyexectioninfobean() const;

  public:
  void clear_strategyexectioninfobean() ;
  const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& strategyexectioninfobean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE release_strategyexectioninfobean();
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NONNULL mutable_strategyexectioninfobean();
  void set_allocated_strategyexectioninfobean(::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_strategyexectioninfobean(::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE unsafe_arena_release_strategyexectioninfobean();

  private:
  const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& _internal_strategyexectioninfobean() const;
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NONNULL _internal_mutable_strategyexectioninfobean();

  public:
  // .lampyris.crypto.protocol.strategy.ResQueryStrategyExectionInfo resQueryStrategyExectionInfo = 31;
  bool has_resquerystrategyexectioninfo() const;
  private:
  bool _internal_has_resquerystrategyexectioninfo() const;

  public:
  void clear_resquerystrategyexectioninfo() ;
  const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& resquerystrategyexectioninfo() const;
  [[nodiscard]] ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE release_resquerystrategyexectioninfo();
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NONNULL mutable_resquerystrategyexectioninfo();
  void set_allocated_resquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resquerystrategyexectioninfo(::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE unsafe_arena_release_resquerystrategyexectioninfo();

  private:
  const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& _internal_resquerystrategyexectioninfo() const;
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NONNULL _internal_mutable_resquerystrategyexectioninfo();

  public:
  // .lampyris.crypto.protocol.trading.ConditionTriggerBean conditionTriggerBean = 32;
  bool has_conditiontriggerbean() const;
  private:
  bool _internal_has_conditiontriggerbean() const;

  public:
  void clear_conditiontriggerbean() ;
  const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& conditiontriggerbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE release_conditiontriggerbean();
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NONNULL mutable_conditiontriggerbean();
  void set_allocated_conditiontriggerbean(::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_conditiontriggerbean(::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE unsafe_arena_release_conditiontriggerbean();

  private:
  const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& _internal_conditiontriggerbean() const;
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NONNULL _internal_mutable_conditiontriggerbean();

  public:
  // .lampyris.crypto.protocol.trading.OrderBean orderBean = 33;
  bool has_orderbean() const;
  private:
  bool _internal_has_orderbean() const;

  public:
  void clear_orderbean() ;
  const ::lampyris::crypto::protocol::trading::OrderBean& orderbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE release_orderbean();
  ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NONNULL mutable_orderbean();
  void set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_orderbean(::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE unsafe_arena_release_orderbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderBean& _internal_orderbean() const;
  ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NONNULL _internal_mutable_orderbean();

  public:
  // .lampyris.crypto.protocol.trading.OrderStatusBean orderStatusBean = 34;
  bool has_orderstatusbean() const;
  private:
  bool _internal_has_orderstatusbean() const;

  public:
  void clear_orderstatusbean() ;
  const ::lampyris::crypto::protocol::trading::OrderStatusBean& orderstatusbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE release_orderstatusbean();
  ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NONNULL mutable_orderstatusbean();
  void set_allocated_orderstatusbean(::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_orderstatusbean(::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE unsafe_arena_release_orderstatusbean();

  private:
  const ::lampyris::crypto::protocol::trading::OrderStatusBean& _internal_orderstatusbean() const;
  ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NONNULL _internal_mutable_orderstatusbean();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryOrders resQueryOrders = 35;
  bool has_resqueryorders() const;
  private:
  bool _internal_has_resqueryorders() const;

  public:
  void clear_resqueryorders() ;
  const ::lampyris::crypto::protocol::trading::ResQueryOrders& resqueryorders() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE release_resqueryorders();
  ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NONNULL mutable_resqueryorders();
  void set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resqueryorders(::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE unsafe_arena_release_resqueryorders();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryOrders& _internal_resqueryorders() const;
  ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NONNULL _internal_mutable_resqueryorders();

  public:
  // .lampyris.crypto.protocol.trading.PositionBean positionBean = 36;
  bool has_positionbean() const;
  private:
  bool _internal_has_positionbean() const;

  public:
  void clear_positionbean() ;
  const ::lampyris::crypto::protocol::trading::PositionBean& positionbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE release_positionbean();
  ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NONNULL mutable_positionbean();
  void set_allocated_positionbean(::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_positionbean(::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE unsafe_arena_release_positionbean();

  private:
  const ::lampyris::crypto::protocol::trading::PositionBean& _internal_positionbean() const;
  ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NONNULL _internal_mutable_positionbean();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryPositions resQueryPositions = 37;
  bool has_resquerypositions() const;
  private:
  bool _internal_has_resquerypositions() const;

  public:
  void clear_resquerypositions() ;
  const ::lampyris::crypto::protocol::trading::ResQueryPositions& resquerypositions() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE release_resquerypositions();
  ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NONNULL mutable_resquerypositions();
  void set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resquerypositions(::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE unsafe_arena_release_resquerypositions();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryPositions& _internal_resquerypositions() const;
  ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NONNULL _internal_mutable_resquerypositions();

  public:
  // .lampyris.crypto.protocol.trading.LeverageBean leverageBean = 38;
  bool has_leveragebean() const;
  private:
  bool _internal_has_leveragebean() const;

  public:
  void clear_leveragebean() ;
  const ::lampyris::crypto::protocol::trading::LeverageBean& leveragebean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE release_leveragebean();
  ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NONNULL mutable_leveragebean();
  void set_allocated_leveragebean(::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_leveragebean(::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE unsafe_arena_release_leveragebean();

  private:
  const ::lampyris::crypto::protocol::trading::LeverageBean& _internal_leveragebean() const;
  ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NONNULL _internal_mutable_leveragebean();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryLeverage resQueryLeverage = 39;
  bool has_resqueryleverage() const;
  private:
  bool _internal_has_resqueryleverage() const;

  public:
  void clear_resqueryleverage() ;
  const ::lampyris::crypto::protocol::trading::ResQueryLeverage& resqueryleverage() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE release_resqueryleverage();
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NONNULL mutable_resqueryleverage();
  void set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resqueryleverage(::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE unsafe_arena_release_resqueryleverage();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryLeverage& _internal_resqueryleverage() const;
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NONNULL _internal_mutable_resqueryleverage();

  public:
  // .lampyris.crypto.protocol.trading.ResQueryLeverageBracket resQueryLeverageBracket = 40;
  bool has_resqueryleveragebracket() const;
  private:
  bool _internal_has_resqueryleveragebracket() const;

  public:
  void clear_resqueryleveragebracket() ;
  const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& resqueryleveragebracket() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE release_resqueryleveragebracket();
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NONNULL mutable_resqueryleveragebracket();
  void set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_resqueryleveragebracket(::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE unsafe_arena_release_resqueryleveragebracket();

  private:
  const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& _internal_resqueryleveragebracket() const;
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NONNULL _internal_mutable_resqueryleveragebracket();

  public:
  // .lampyris.crypto.protocol.trading.SymbolLeverageBracketBean symbolLeverageBracketBean = 41;
  bool has_symbolleveragebracketbean() const;
  private:
  bool _internal_has_symbolleveragebracketbean() const;

  public:
  void clear_symbolleveragebracketbean() ;
  const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& symbolleveragebracketbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE release_symbolleveragebracketbean();
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NONNULL mutable_symbolleveragebracketbean();
  void set_allocated_symbolleveragebracketbean(::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_symbolleveragebracketbean(::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE unsafe_arena_release_symbolleveragebracketbean();

  private:
  const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& _internal_symbolleveragebracketbean() const;
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NONNULL _internal_mutable_symbolleveragebracketbean();

  public:
  // .lampyris.crypto.protocol.trading.LeverageBracketBean leverageBracketBean = 42;
  bool has_leveragebracketbean() const;
  private:
  bool _internal_has_leveragebracketbean() const;

  public:
  void clear_leveragebracketbean() ;
  const ::lampyris::crypto::protocol::trading::LeverageBracketBean& leveragebracketbean() const;
  [[nodiscard]] ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE release_leveragebracketbean();
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NONNULL mutable_leveragebracketbean();
  void set_allocated_leveragebracketbean(::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_leveragebracketbean(::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE value);
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE unsafe_arena_release_leveragebracketbean();

  private:
  const ::lampyris::crypto::protocol::trading::LeverageBracketBean& _internal_leveragebracketbean() const;
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NONNULL _internal_mutable_leveragebracketbean();

  public:
  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:lampyris.crypto.protocol.common.Response)
 private:
  class _Internal;
  void set_has_accountassetinfobean();
  void set_has_subaccountinfobean();
  void set_has_resquerysubacccountlist();
  void set_has_resaccountsummaryupdate();
  void set_has_assettransferhistoryinfodetailbean();
  void set_has_assettransferhistoryinfobean();
  void set_has_reslogin();
  void set_has_resheartbeat();
  void set_has_resnotice();
  void set_has_symboltickerdatabean();
  void set_has_ressubscribetickerdata();
  void set_has_symboltradedatabean();
  void set_has_tradedatabean();
  void set_has_rescandlestickquery();
  void set_has_candlestickupdatebean();
  void set_has_candlestickbean();
  void set_has_restraderule();
  void set_has_symboltraderulebean();
  void set_has_marketmonitornoticelistbean();
  void set_has_marketmonitornoticebean();
  void set_has_selfselectedsymbolinfobean();
  void set_has_selfselectedsymbolgroupbean();
  void set_has_resselfselectedsymbol();
  void set_has_marketpreviewintervaldatabean();
  void set_has_resmarketpreviewdata();
  void set_has_streategyconfigbean();
  void set_has_streategyfieldbean();
  void set_has_resmodifystreategysetting();
  void set_has_resstreategysettings();
  void set_has_strategyexectioninfobean();
  void set_has_resquerystrategyexectioninfo();
  void set_has_conditiontriggerbean();
  void set_has_orderbean();
  void set_has_orderstatusbean();
  void set_has_resqueryorders();
  void set_has_positionbean();
  void set_has_resquerypositions();
  void set_has_leveragebean();
  void set_has_resqueryleverage();
  void set_has_resqueryleveragebracket();
  void set_has_symbolleveragebracketbean();
  void set_has_leveragebracketbean();
  inline bool has_response_type() const;
  inline void clear_has_response_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 42,
                                   42, 0,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Response& from_msg);
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE accountassetinfobean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subaccountinfobean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resquerysubacccountlist_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resaccountsummaryupdate_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE assettransferhistoryinfodetailbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE assettransferhistoryinfobean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reslogin_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resheartbeat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resnotice_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE symboltickerdatabean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ressubscribetickerdata_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE symboltradedatabean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE tradedatabean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE rescandlestickquery_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE candlestickupdatebean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE candlestickbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE restraderule_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE symboltraderulebean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE marketmonitornoticelistbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE marketmonitornoticebean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE selfselectedsymbolinfobean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE selfselectedsymbolgroupbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resselfselectedsymbol_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE marketpreviewintervaldatabean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resmarketpreviewdata_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE streategyconfigbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE streategyfieldbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resmodifystreategysetting_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resstreategysettings_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE strategyexectioninfobean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resquerystrategyexectioninfo_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE conditiontriggerbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE orderbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE orderstatusbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resqueryorders_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE positionbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resquerypositions_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE leveragebean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resqueryleverage_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE resqueryleveragebracket_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE symbolleveragebracketbean_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE leveragebracketbean_;
    } response_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Response_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Request

// .lampyris.crypto.protocol.account.ReqAccountSummaryUpdate reqAccountSummaryUpdate = 1;
inline bool Request::has_reqaccountsummaryupdate() const {
  return request_type_case() == kReqAccountSummaryUpdate;
}
inline bool Request::_internal_has_reqaccountsummaryupdate() const {
  return request_type_case() == kReqAccountSummaryUpdate;
}
inline void Request::set_has_reqaccountsummaryupdate() {
  _impl_._oneof_case_[0] = kReqAccountSummaryUpdate;
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE Request::release_reqaccountsummaryupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  if (request_type_case() == kReqAccountSummaryUpdate) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate*>(_impl_.request_type_.reqaccountsummaryupdate_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& Request::_internal_reqaccountsummaryupdate() const {
  return request_type_case() == kReqAccountSummaryUpdate ? *reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate*>(_impl_.request_type_.reqaccountsummaryupdate_) : reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate&>(::lampyris::crypto::protocol::account::_ReqAccountSummaryUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate& Request::reqaccountsummaryupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  return _internal_reqaccountsummaryupdate();
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqaccountsummaryupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  if (request_type_case() == kReqAccountSummaryUpdate) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate*>(_impl_.request_type_.reqaccountsummaryupdate_);
    _impl_.request_type_.reqaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqaccountsummaryupdate(
    ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqaccountsummaryupdate();
    _impl_.request_type_.reqaccountsummaryupdate_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NONNULL Request::_internal_mutable_reqaccountsummaryupdate() {
  if (request_type_case() != kReqAccountSummaryUpdate) {
    clear_request_type();
    set_has_reqaccountsummaryupdate();
    _impl_.request_type_.reqaccountsummaryupdate_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate*>(_impl_.request_type_.reqaccountsummaryupdate_);
}
inline ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* PROTOBUF_NONNULL Request::mutable_reqaccountsummaryupdate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ReqAccountSummaryUpdate* _msg = _internal_mutable_reqaccountsummaryupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqAccountSummaryUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.account.ReqAccountAssetTransfer reqAccountAssetTransfer = 2;
inline bool Request::has_reqaccountassettransfer() const {
  return request_type_case() == kReqAccountAssetTransfer;
}
inline bool Request::_internal_has_reqaccountassettransfer() const {
  return request_type_case() == kReqAccountAssetTransfer;
}
inline void Request::set_has_reqaccountassettransfer() {
  _impl_._oneof_case_[0] = kReqAccountAssetTransfer;
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE Request::release_reqaccountassettransfer() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  if (request_type_case() == kReqAccountAssetTransfer) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer*>(_impl_.request_type_.reqaccountassettransfer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqaccountassettransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& Request::_internal_reqaccountassettransfer() const {
  return request_type_case() == kReqAccountAssetTransfer ? *reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer*>(_impl_.request_type_.reqaccountassettransfer_) : reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer&>(::lampyris::crypto::protocol::account::_ReqAccountAssetTransfer_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer& Request::reqaccountassettransfer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  return _internal_reqaccountassettransfer();
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqaccountassettransfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  if (request_type_case() == kReqAccountAssetTransfer) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer*>(_impl_.request_type_.reqaccountassettransfer_);
    _impl_.request_type_.reqaccountassettransfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqaccountassettransfer(
    ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqaccountassettransfer();
    _impl_.request_type_.reqaccountassettransfer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NONNULL Request::_internal_mutable_reqaccountassettransfer() {
  if (request_type_case() != kReqAccountAssetTransfer) {
    clear_request_type();
    set_has_reqaccountassettransfer();
    _impl_.request_type_.reqaccountassettransfer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::ReqAccountAssetTransfer*>(_impl_.request_type_.reqaccountassettransfer_);
}
inline ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* PROTOBUF_NONNULL Request::mutable_reqaccountassettransfer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ReqAccountAssetTransfer* _msg = _internal_mutable_reqaccountassettransfer();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqAccountAssetTransfer)
  return _msg;
}

// .lampyris.crypto.protocol.account.ReqQueryAssetTransferHistory reqQueryAssetTransferHistory = 3;
inline bool Request::has_reqqueryassettransferhistory() const {
  return request_type_case() == kReqQueryAssetTransferHistory;
}
inline bool Request::_internal_has_reqqueryassettransferhistory() const {
  return request_type_case() == kReqQueryAssetTransferHistory;
}
inline void Request::set_has_reqqueryassettransferhistory() {
  _impl_._oneof_case_[0] = kReqQueryAssetTransferHistory;
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE Request::release_reqqueryassettransferhistory() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  if (request_type_case() == kReqQueryAssetTransferHistory) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory*>(_impl_.request_type_.reqqueryassettransferhistory_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryassettransferhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& Request::_internal_reqqueryassettransferhistory() const {
  return request_type_case() == kReqQueryAssetTransferHistory ? *reinterpret_cast<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory*>(_impl_.request_type_.reqqueryassettransferhistory_) : reinterpret_cast<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory&>(::lampyris::crypto::protocol::account::_ReqQueryAssetTransferHistory_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory& Request::reqqueryassettransferhistory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  return _internal_reqqueryassettransferhistory();
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqqueryassettransferhistory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  if (request_type_case() == kReqQueryAssetTransferHistory) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory*>(_impl_.request_type_.reqqueryassettransferhistory_);
    _impl_.request_type_.reqqueryassettransferhistory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryassettransferhistory(
    ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryassettransferhistory();
    _impl_.request_type_.reqqueryassettransferhistory_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NONNULL Request::_internal_mutable_reqqueryassettransferhistory() {
  if (request_type_case() != kReqQueryAssetTransferHistory) {
    clear_request_type();
    set_has_reqqueryassettransferhistory();
    _impl_.request_type_.reqqueryassettransferhistory_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory*>(_impl_.request_type_.reqqueryassettransferhistory_);
}
inline ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* PROTOBUF_NONNULL Request::mutable_reqqueryassettransferhistory()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ReqQueryAssetTransferHistory* _msg = _internal_mutable_reqqueryassettransferhistory();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryAssetTransferHistory)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqLogin reqLogin = 4;
inline bool Request::has_reqlogin() const {
  return request_type_case() == kReqLogin;
}
inline bool Request::_internal_has_reqlogin() const {
  return request_type_case() == kReqLogin;
}
inline void Request::set_has_reqlogin() {
  _impl_._oneof_case_[0] = kReqLogin;
}
inline ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE Request::release_reqlogin() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqLogin)
  if (request_type_case() == kReqLogin) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogin*>(_impl_.request_type_.reqlogin_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqlogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqLogin& Request::_internal_reqlogin() const {
  return request_type_case() == kReqLogin ? *reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogin*>(_impl_.request_type_.reqlogin_) : reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogin&>(::lampyris::crypto::protocol::app::_ReqLogin_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqLogin& Request::reqlogin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqLogin)
  return _internal_reqlogin();
}
inline ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqlogin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqLogin)
  if (request_type_case() == kReqLogin) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogin*>(_impl_.request_type_.reqlogin_);
    _impl_.request_type_.reqlogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqlogin(
    ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqlogin();
    _impl_.request_type_.reqlogin_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqLogin)
}
inline ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NONNULL Request::_internal_mutable_reqlogin() {
  if (request_type_case() != kReqLogin) {
    clear_request_type();
    set_has_reqlogin();
    _impl_.request_type_.reqlogin_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqLogin>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogin*>(_impl_.request_type_.reqlogin_);
}
inline ::lampyris::crypto::protocol::app::ReqLogin* PROTOBUF_NONNULL Request::mutable_reqlogin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqLogin* _msg = _internal_mutable_reqlogin();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqLogin)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqLogout reqLogout = 5;
inline bool Request::has_reqlogout() const {
  return request_type_case() == kReqLogout;
}
inline bool Request::_internal_has_reqlogout() const {
  return request_type_case() == kReqLogout;
}
inline void Request::set_has_reqlogout() {
  _impl_._oneof_case_[0] = kReqLogout;
}
inline ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE Request::release_reqlogout() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqLogout)
  if (request_type_case() == kReqLogout) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogout*>(_impl_.request_type_.reqlogout_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqLogout& Request::_internal_reqlogout() const {
  return request_type_case() == kReqLogout ? *reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogout*>(_impl_.request_type_.reqlogout_) : reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogout&>(::lampyris::crypto::protocol::app::_ReqLogout_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqLogout& Request::reqlogout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqLogout)
  return _internal_reqlogout();
}
inline ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqlogout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqLogout)
  if (request_type_case() == kReqLogout) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogout*>(_impl_.request_type_.reqlogout_);
    _impl_.request_type_.reqlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqlogout(
    ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqlogout();
    _impl_.request_type_.reqlogout_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqLogout)
}
inline ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NONNULL Request::_internal_mutable_reqlogout() {
  if (request_type_case() != kReqLogout) {
    clear_request_type();
    set_has_reqlogout();
    _impl_.request_type_.reqlogout_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqLogout>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ReqLogout*>(_impl_.request_type_.reqlogout_);
}
inline ::lampyris::crypto::protocol::app::ReqLogout* PROTOBUF_NONNULL Request::mutable_reqlogout()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqLogout* _msg = _internal_mutable_reqlogout();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqLogout)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqHeartBeat reqHeartBeat = 6;
inline bool Request::has_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat;
}
inline bool Request::_internal_has_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat;
}
inline void Request::set_has_reqheartbeat() {
  _impl_._oneof_case_[0] = kReqHeartBeat;
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE Request::release_reqheartbeat() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  if (request_type_case() == kReqHeartBeat) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat*>(_impl_.request_type_.reqheartbeat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqHeartBeat& Request::_internal_reqheartbeat() const {
  return request_type_case() == kReqHeartBeat ? *reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat*>(_impl_.request_type_.reqheartbeat_) : reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat&>(::lampyris::crypto::protocol::app::_ReqHeartBeat_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqHeartBeat& Request::reqheartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  return _internal_reqheartbeat();
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqheartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  if (request_type_case() == kReqHeartBeat) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat*>(_impl_.request_type_.reqheartbeat_);
    _impl_.request_type_.reqheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqheartbeat(
    ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqheartbeat();
    _impl_.request_type_.reqheartbeat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqHeartBeat)
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NONNULL Request::_internal_mutable_reqheartbeat() {
  if (request_type_case() != kReqHeartBeat) {
    clear_request_type();
    set_has_reqheartbeat();
    _impl_.request_type_.reqheartbeat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqHeartBeat>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ReqHeartBeat*>(_impl_.request_type_.reqheartbeat_);
}
inline ::lampyris::crypto::protocol::app::ReqHeartBeat* PROTOBUF_NONNULL Request::mutable_reqheartbeat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqHeartBeat* _msg = _internal_mutable_reqheartbeat();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqHeartBeat)
  return _msg;
}

// .lampyris.crypto.protocol.app.ReqUploadAppBehaviour reqUploadAppBehaviour = 7;
inline bool Request::has_requploadappbehaviour() const {
  return request_type_case() == kReqUploadAppBehaviour;
}
inline bool Request::_internal_has_requploadappbehaviour() const {
  return request_type_case() == kReqUploadAppBehaviour;
}
inline void Request::set_has_requploadappbehaviour() {
  _impl_._oneof_case_[0] = kReqUploadAppBehaviour;
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE Request::release_requploadappbehaviour() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  if (request_type_case() == kReqUploadAppBehaviour) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour*>(_impl_.request_type_.requploadappbehaviour_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.requploadappbehaviour_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& Request::_internal_requploadappbehaviour() const {
  return request_type_case() == kReqUploadAppBehaviour ? *reinterpret_cast<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour*>(_impl_.request_type_.requploadappbehaviour_) : reinterpret_cast<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour&>(::lampyris::crypto::protocol::app::_ReqUploadAppBehaviour_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour& Request::requploadappbehaviour() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  return _internal_requploadappbehaviour();
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE Request::unsafe_arena_release_requploadappbehaviour() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  if (request_type_case() == kReqUploadAppBehaviour) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour*>(_impl_.request_type_.requploadappbehaviour_);
    _impl_.request_type_.requploadappbehaviour_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_requploadappbehaviour(
    ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_requploadappbehaviour();
    _impl_.request_type_.requploadappbehaviour_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NONNULL Request::_internal_mutable_requploadappbehaviour() {
  if (request_type_case() != kReqUploadAppBehaviour) {
    clear_request_type();
    set_has_requploadappbehaviour();
    _impl_.request_type_.requploadappbehaviour_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ReqUploadAppBehaviour*>(_impl_.request_type_.requploadappbehaviour_);
}
inline ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* PROTOBUF_NONNULL Request::mutable_requploadappbehaviour()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ReqUploadAppBehaviour* _msg = _internal_mutable_requploadappbehaviour();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqUploadAppBehaviour)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeTickerData reqSubscribeTickerData = 8;
inline bool Request::has_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData;
}
inline bool Request::_internal_has_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData;
}
inline void Request::set_has_reqsubscribetickerdata() {
  _impl_._oneof_case_[0] = kReqSubscribeTickerData;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE Request::release_reqsubscribetickerdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  if (request_type_case() == kReqSubscribeTickerData) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData*>(_impl_.request_type_.reqsubscribetickerdata_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& Request::_internal_reqsubscribetickerdata() const {
  return request_type_case() == kReqSubscribeTickerData ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData*>(_impl_.request_type_.reqsubscribetickerdata_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData&>(::lampyris::crypto::protocol::quote::_ReqSubscribeTickerData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData& Request::reqsubscribetickerdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  return _internal_reqsubscribetickerdata();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqsubscribetickerdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  if (request_type_case() == kReqSubscribeTickerData) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData*>(_impl_.request_type_.reqsubscribetickerdata_);
    _impl_.request_type_.reqsubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribetickerdata(
    ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribetickerdata();
    _impl_.request_type_.reqsubscribetickerdata_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NONNULL Request::_internal_mutable_reqsubscribetickerdata() {
  if (request_type_case() != kReqSubscribeTickerData) {
    clear_request_type();
    set_has_reqsubscribetickerdata();
    _impl_.request_type_.reqsubscribetickerdata_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTickerData*>(_impl_.request_type_.reqsubscribetickerdata_);
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* PROTOBUF_NONNULL Request::mutable_reqsubscribetickerdata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeTickerData* _msg = _internal_mutable_reqsubscribetickerdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeTickerData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeTradeData reqSubscribeTradeData = 9;
inline bool Request::has_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData;
}
inline bool Request::_internal_has_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData;
}
inline void Request::set_has_reqsubscribetradedata() {
  _impl_._oneof_case_[0] = kReqSubscribeTradeData;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE Request::release_reqsubscribetradedata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  if (request_type_case() == kReqSubscribeTradeData) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData*>(_impl_.request_type_.reqsubscribetradedata_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribetradedata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& Request::_internal_reqsubscribetradedata() const {
  return request_type_case() == kReqSubscribeTradeData ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData*>(_impl_.request_type_.reqsubscribetradedata_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData&>(::lampyris::crypto::protocol::quote::_ReqSubscribeTradeData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData& Request::reqsubscribetradedata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  return _internal_reqsubscribetradedata();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqsubscribetradedata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  if (request_type_case() == kReqSubscribeTradeData) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData*>(_impl_.request_type_.reqsubscribetradedata_);
    _impl_.request_type_.reqsubscribetradedata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribetradedata(
    ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribetradedata();
    _impl_.request_type_.reqsubscribetradedata_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NONNULL Request::_internal_mutable_reqsubscribetradedata() {
  if (request_type_case() != kReqSubscribeTradeData) {
    clear_request_type();
    set_has_reqsubscribetradedata();
    _impl_.request_type_.reqsubscribetradedata_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeTradeData*>(_impl_.request_type_.reqsubscribetradedata_);
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* PROTOBUF_NONNULL Request::mutable_reqsubscribetradedata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeTradeData* _msg = _internal_mutable_reqsubscribetradedata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeTradeData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSubscribeCandlestickUpdate reqSubscribeCandlestickUpdate = 10;
inline bool Request::has_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate;
}
inline bool Request::_internal_has_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate;
}
inline void Request::set_has_reqsubscribecandlestickupdate() {
  _impl_._oneof_case_[0] = kReqSubscribeCandlestickUpdate;
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE Request::release_reqsubscribecandlestickupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  if (request_type_case() == kReqSubscribeCandlestickUpdate) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate*>(_impl_.request_type_.reqsubscribecandlestickupdate_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsubscribecandlestickupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& Request::_internal_reqsubscribecandlestickupdate() const {
  return request_type_case() == kReqSubscribeCandlestickUpdate ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate*>(_impl_.request_type_.reqsubscribecandlestickupdate_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate&>(::lampyris::crypto::protocol::quote::_ReqSubscribeCandlestickUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate& Request::reqsubscribecandlestickupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  return _internal_reqsubscribecandlestickupdate();
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqsubscribecandlestickupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  if (request_type_case() == kReqSubscribeCandlestickUpdate) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate*>(_impl_.request_type_.reqsubscribecandlestickupdate_);
    _impl_.request_type_.reqsubscribecandlestickupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsubscribecandlestickupdate(
    ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsubscribecandlestickupdate();
    _impl_.request_type_.reqsubscribecandlestickupdate_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NONNULL Request::_internal_mutable_reqsubscribecandlestickupdate() {
  if (request_type_case() != kReqSubscribeCandlestickUpdate) {
    clear_request_type();
    set_has_reqsubscribecandlestickupdate();
    _impl_.request_type_.reqsubscribecandlestickupdate_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate*>(_impl_.request_type_.reqsubscribecandlestickupdate_);
}
inline ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* PROTOBUF_NONNULL Request::mutable_reqsubscribecandlestickupdate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSubscribeCandlestickUpdate* _msg = _internal_mutable_reqsubscribecandlestickupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSubscribeCandlestickUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqCandlestickQuery reqCandlestickQuery = 11;
inline bool Request::has_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery;
}
inline bool Request::_internal_has_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery;
}
inline void Request::set_has_reqcandlestickquery() {
  _impl_._oneof_case_[0] = kReqCandlestickQuery;
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE Request::release_reqcandlestickquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  if (request_type_case() == kReqCandlestickQuery) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery*>(_impl_.request_type_.reqcandlestickquery_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqcandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& Request::_internal_reqcandlestickquery() const {
  return request_type_case() == kReqCandlestickQuery ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery*>(_impl_.request_type_.reqcandlestickquery_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery&>(::lampyris::crypto::protocol::quote::_ReqCandlestickQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqCandlestickQuery& Request::reqcandlestickquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  return _internal_reqcandlestickquery();
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqcandlestickquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  if (request_type_case() == kReqCandlestickQuery) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery*>(_impl_.request_type_.reqcandlestickquery_);
    _impl_.request_type_.reqcandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqcandlestickquery(
    ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqcandlestickquery();
    _impl_.request_type_.reqcandlestickquery_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NONNULL Request::_internal_mutable_reqcandlestickquery() {
  if (request_type_case() != kReqCandlestickQuery) {
    clear_request_type();
    set_has_reqcandlestickquery();
    _impl_.request_type_.reqcandlestickquery_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqCandlestickQuery>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ReqCandlestickQuery*>(_impl_.request_type_.reqcandlestickquery_);
}
inline ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* PROTOBUF_NONNULL Request::mutable_reqcandlestickquery()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqCandlestickQuery* _msg = _internal_mutable_reqcandlestickquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqCandlestickQuery)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqTradeRule reqTradeRule = 12;
inline bool Request::has_reqtraderule() const {
  return request_type_case() == kReqTradeRule;
}
inline bool Request::_internal_has_reqtraderule() const {
  return request_type_case() == kReqTradeRule;
}
inline void Request::set_has_reqtraderule() {
  _impl_._oneof_case_[0] = kReqTradeRule;
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE Request::release_reqtraderule() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqTradeRule)
  if (request_type_case() == kReqTradeRule) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule*>(_impl_.request_type_.reqtraderule_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqtraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqTradeRule& Request::_internal_reqtraderule() const {
  return request_type_case() == kReqTradeRule ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule*>(_impl_.request_type_.reqtraderule_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule&>(::lampyris::crypto::protocol::quote::_ReqTradeRule_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqTradeRule& Request::reqtraderule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqTradeRule)
  return _internal_reqtraderule();
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqtraderule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqTradeRule)
  if (request_type_case() == kReqTradeRule) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule*>(_impl_.request_type_.reqtraderule_);
    _impl_.request_type_.reqtraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqtraderule(
    ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqtraderule();
    _impl_.request_type_.reqtraderule_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqTradeRule)
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NONNULL Request::_internal_mutable_reqtraderule() {
  if (request_type_case() != kReqTradeRule) {
    clear_request_type();
    set_has_reqtraderule();
    _impl_.request_type_.reqtraderule_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqTradeRule>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ReqTradeRule*>(_impl_.request_type_.reqtraderule_);
}
inline ::lampyris::crypto::protocol::quote::ReqTradeRule* PROTOBUF_NONNULL Request::mutable_reqtraderule()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqTradeRule* _msg = _internal_mutable_reqtraderule();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqTradeRule)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ReqSelfSelectedSymbol reqSelfSelectedSymbol = 13;
inline bool Request::has_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol;
}
inline bool Request::_internal_has_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol;
}
inline void Request::set_has_reqselfselectedsymbol() {
  _impl_._oneof_case_[0] = kReqSelfSelectedSymbol;
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE Request::release_reqselfselectedsymbol() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  if (request_type_case() == kReqSelfSelectedSymbol) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol*>(_impl_.request_type_.reqselfselectedsymbol_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& Request::_internal_reqselfselectedsymbol() const {
  return request_type_case() == kReqSelfSelectedSymbol ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol*>(_impl_.request_type_.reqselfselectedsymbol_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol&>(::lampyris::crypto::protocol::quote::_ReqSelfSelectedSymbol_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol& Request::reqselfselectedsymbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  return _internal_reqselfselectedsymbol();
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqselfselectedsymbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  if (request_type_case() == kReqSelfSelectedSymbol) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol*>(_impl_.request_type_.reqselfselectedsymbol_);
    _impl_.request_type_.reqselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqselfselectedsymbol(
    ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqselfselectedsymbol();
    _impl_.request_type_.reqselfselectedsymbol_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NONNULL Request::_internal_mutable_reqselfselectedsymbol() {
  if (request_type_case() != kReqSelfSelectedSymbol) {
    clear_request_type();
    set_has_reqselfselectedsymbol();
    _impl_.request_type_.reqselfselectedsymbol_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol*>(_impl_.request_type_.reqselfselectedsymbol_);
}
inline ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* PROTOBUF_NONNULL Request::mutable_reqselfselectedsymbol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ReqSelfSelectedSymbol* _msg = _internal_mutable_reqselfselectedsymbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSelfSelectedSymbol)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqModifyStreategySetting reqModifyStreategySetting = 14;
inline bool Request::has_reqmodifystreategysetting() const {
  return request_type_case() == kReqModifyStreategySetting;
}
inline bool Request::_internal_has_reqmodifystreategysetting() const {
  return request_type_case() == kReqModifyStreategySetting;
}
inline void Request::set_has_reqmodifystreategysetting() {
  _impl_._oneof_case_[0] = kReqModifyStreategySetting;
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE Request::release_reqmodifystreategysetting() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  if (request_type_case() == kReqModifyStreategySetting) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting*>(_impl_.request_type_.reqmodifystreategysetting_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& Request::_internal_reqmodifystreategysetting() const {
  return request_type_case() == kReqModifyStreategySetting ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting*>(_impl_.request_type_.reqmodifystreategysetting_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting&>(::lampyris::crypto::protocol::strategy::_ReqModifyStreategySetting_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting& Request::reqmodifystreategysetting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  return _internal_reqmodifystreategysetting();
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqmodifystreategysetting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  if (request_type_case() == kReqModifyStreategySetting) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting*>(_impl_.request_type_.reqmodifystreategysetting_);
    _impl_.request_type_.reqmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqmodifystreategysetting(
    ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqmodifystreategysetting();
    _impl_.request_type_.reqmodifystreategysetting_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NONNULL Request::_internal_mutable_reqmodifystreategysetting() {
  if (request_type_case() != kReqModifyStreategySetting) {
    clear_request_type();
    set_has_reqmodifystreategysetting();
    _impl_.request_type_.reqmodifystreategysetting_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting*>(_impl_.request_type_.reqmodifystreategysetting_);
}
inline ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* PROTOBUF_NONNULL Request::mutable_reqmodifystreategysetting()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqModifyStreategySetting* _msg = _internal_mutable_reqmodifystreategysetting();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqModifyStreategySetting)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ReqQueryStrategyExectionInfo reqQueryStrategyExectionInfo = 15;
inline bool Request::has_reqquerystrategyexectioninfo() const {
  return request_type_case() == kReqQueryStrategyExectionInfo;
}
inline bool Request::_internal_has_reqquerystrategyexectioninfo() const {
  return request_type_case() == kReqQueryStrategyExectionInfo;
}
inline void Request::set_has_reqquerystrategyexectioninfo() {
  _impl_._oneof_case_[0] = kReqQueryStrategyExectionInfo;
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE Request::release_reqquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  if (request_type_case() == kReqQueryStrategyExectionInfo) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo*>(_impl_.request_type_.reqquerystrategyexectioninfo_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& Request::_internal_reqquerystrategyexectioninfo() const {
  return request_type_case() == kReqQueryStrategyExectionInfo ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo*>(_impl_.request_type_.reqquerystrategyexectioninfo_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo&>(::lampyris::crypto::protocol::strategy::_ReqQueryStrategyExectionInfo_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo& Request::reqquerystrategyexectioninfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  return _internal_reqquerystrategyexectioninfo();
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  if (request_type_case() == kReqQueryStrategyExectionInfo) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo*>(_impl_.request_type_.reqquerystrategyexectioninfo_);
    _impl_.request_type_.reqquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqquerystrategyexectioninfo(
    ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqquerystrategyexectioninfo();
    _impl_.request_type_.reqquerystrategyexectioninfo_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NONNULL Request::_internal_mutable_reqquerystrategyexectioninfo() {
  if (request_type_case() != kReqQueryStrategyExectionInfo) {
    clear_request_type();
    set_has_reqquerystrategyexectioninfo();
    _impl_.request_type_.reqquerystrategyexectioninfo_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo*>(_impl_.request_type_.reqquerystrategyexectioninfo_);
}
inline ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* PROTOBUF_NONNULL Request::mutable_reqquerystrategyexectioninfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ReqQueryStrategyExectionInfo* _msg = _internal_mutable_reqquerystrategyexectioninfo();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryStrategyExectionInfo)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqPlaceOrder reqPlaceOrder = 16;
inline bool Request::has_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder;
}
inline bool Request::_internal_has_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder;
}
inline void Request::set_has_reqplaceorder() {
  _impl_._oneof_case_[0] = kReqPlaceOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE Request::release_reqplaceorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  if (request_type_case() == kReqPlaceOrder) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder*>(_impl_.request_type_.reqplaceorder_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqplaceorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& Request::_internal_reqplaceorder() const {
  return request_type_case() == kReqPlaceOrder ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder*>(_impl_.request_type_.reqplaceorder_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder&>(::lampyris::crypto::protocol::trading::_ReqPlaceOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqPlaceOrder& Request::reqplaceorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  return _internal_reqplaceorder();
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqplaceorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  if (request_type_case() == kReqPlaceOrder) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder*>(_impl_.request_type_.reqplaceorder_);
    _impl_.request_type_.reqplaceorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqplaceorder(
    ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqplaceorder();
    _impl_.request_type_.reqplaceorder_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NONNULL Request::_internal_mutable_reqplaceorder() {
  if (request_type_case() != kReqPlaceOrder) {
    clear_request_type();
    set_has_reqplaceorder();
    _impl_.request_type_.reqplaceorder_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqPlaceOrder>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqPlaceOrder*>(_impl_.request_type_.reqplaceorder_);
}
inline ::lampyris::crypto::protocol::trading::ReqPlaceOrder* PROTOBUF_NONNULL Request::mutable_reqplaceorder()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqPlaceOrder* _msg = _internal_mutable_reqplaceorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqPlaceOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqModifyOrder reqModifyOrder = 17;
inline bool Request::has_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder;
}
inline bool Request::_internal_has_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder;
}
inline void Request::set_has_reqmodifyorder() {
  _impl_._oneof_case_[0] = kReqModifyOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE Request::release_reqmodifyorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  if (request_type_case() == kReqModifyOrder) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder*>(_impl_.request_type_.reqmodifyorder_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqmodifyorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqModifyOrder& Request::_internal_reqmodifyorder() const {
  return request_type_case() == kReqModifyOrder ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder*>(_impl_.request_type_.reqmodifyorder_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder&>(::lampyris::crypto::protocol::trading::_ReqModifyOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqModifyOrder& Request::reqmodifyorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  return _internal_reqmodifyorder();
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqmodifyorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  if (request_type_case() == kReqModifyOrder) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder*>(_impl_.request_type_.reqmodifyorder_);
    _impl_.request_type_.reqmodifyorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqmodifyorder(
    ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqmodifyorder();
    _impl_.request_type_.reqmodifyorder_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqModifyOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NONNULL Request::_internal_mutable_reqmodifyorder() {
  if (request_type_case() != kReqModifyOrder) {
    clear_request_type();
    set_has_reqmodifyorder();
    _impl_.request_type_.reqmodifyorder_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqModifyOrder>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqModifyOrder*>(_impl_.request_type_.reqmodifyorder_);
}
inline ::lampyris::crypto::protocol::trading::ReqModifyOrder* PROTOBUF_NONNULL Request::mutable_reqmodifyorder()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqModifyOrder* _msg = _internal_mutable_reqmodifyorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqModifyOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqCancelOrder reqCancelOrder = 18;
inline bool Request::has_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder;
}
inline bool Request::_internal_has_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder;
}
inline void Request::set_has_reqcancelorder() {
  _impl_._oneof_case_[0] = kReqCancelOrder;
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE Request::release_reqcancelorder() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  if (request_type_case() == kReqCancelOrder) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder*>(_impl_.request_type_.reqcancelorder_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqcancelorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqCancelOrder& Request::_internal_reqcancelorder() const {
  return request_type_case() == kReqCancelOrder ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder*>(_impl_.request_type_.reqcancelorder_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder&>(::lampyris::crypto::protocol::trading::_ReqCancelOrder_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqCancelOrder& Request::reqcancelorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  return _internal_reqcancelorder();
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqcancelorder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  if (request_type_case() == kReqCancelOrder) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder*>(_impl_.request_type_.reqcancelorder_);
    _impl_.request_type_.reqcancelorder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqcancelorder(
    ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqcancelorder();
    _impl_.request_type_.reqcancelorder_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqCancelOrder)
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NONNULL Request::_internal_mutable_reqcancelorder() {
  if (request_type_case() != kReqCancelOrder) {
    clear_request_type();
    set_has_reqcancelorder();
    _impl_.request_type_.reqcancelorder_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqCancelOrder>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqCancelOrder*>(_impl_.request_type_.reqcancelorder_);
}
inline ::lampyris::crypto::protocol::trading::ReqCancelOrder* PROTOBUF_NONNULL Request::mutable_reqcancelorder()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqCancelOrder* _msg = _internal_mutable_reqcancelorder();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqCancelOrder)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqOneKeyClosePosition reqOneKeyClosePosition = 19;
inline bool Request::has_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition;
}
inline bool Request::_internal_has_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition;
}
inline void Request::set_has_reqonekeycloseposition() {
  _impl_._oneof_case_[0] = kReqOneKeyClosePosition;
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE Request::release_reqonekeycloseposition() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  if (request_type_case() == kReqOneKeyClosePosition) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition*>(_impl_.request_type_.reqonekeycloseposition_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqonekeycloseposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& Request::_internal_reqonekeycloseposition() const {
  return request_type_case() == kReqOneKeyClosePosition ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition*>(_impl_.request_type_.reqonekeycloseposition_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition&>(::lampyris::crypto::protocol::trading::_ReqOneKeyClosePosition_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition& Request::reqonekeycloseposition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  return _internal_reqonekeycloseposition();
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqonekeycloseposition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  if (request_type_case() == kReqOneKeyClosePosition) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition*>(_impl_.request_type_.reqonekeycloseposition_);
    _impl_.request_type_.reqonekeycloseposition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqonekeycloseposition(
    ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqonekeycloseposition();
    _impl_.request_type_.reqonekeycloseposition_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NONNULL Request::_internal_mutable_reqonekeycloseposition() {
  if (request_type_case() != kReqOneKeyClosePosition) {
    clear_request_type();
    set_has_reqonekeycloseposition();
    _impl_.request_type_.reqonekeycloseposition_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition*>(_impl_.request_type_.reqonekeycloseposition_);
}
inline ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* PROTOBUF_NONNULL Request::mutable_reqonekeycloseposition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqOneKeyClosePosition* _msg = _internal_mutable_reqonekeycloseposition();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqOneKeyClosePosition)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryActiveOrders reqQueryActiveOrders = 20;
inline bool Request::has_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders;
}
inline bool Request::_internal_has_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders;
}
inline void Request::set_has_reqqueryactiveorders() {
  _impl_._oneof_case_[0] = kReqQueryActiveOrders;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE Request::release_reqqueryactiveorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  if (request_type_case() == kReqQueryActiveOrders) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders*>(_impl_.request_type_.reqqueryactiveorders_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryactiveorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& Request::_internal_reqqueryactiveorders() const {
  return request_type_case() == kReqQueryActiveOrders ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders*>(_impl_.request_type_.reqqueryactiveorders_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders&>(::lampyris::crypto::protocol::trading::_ReqQueryActiveOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders& Request::reqqueryactiveorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  return _internal_reqqueryactiveorders();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqqueryactiveorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  if (request_type_case() == kReqQueryActiveOrders) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders*>(_impl_.request_type_.reqqueryactiveorders_);
    _impl_.request_type_.reqqueryactiveorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryactiveorders(
    ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryactiveorders();
    _impl_.request_type_.reqqueryactiveorders_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NONNULL Request::_internal_mutable_reqqueryactiveorders() {
  if (request_type_case() != kReqQueryActiveOrders) {
    clear_request_type();
    set_has_reqqueryactiveorders();
    _impl_.request_type_.reqqueryactiveorders_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryActiveOrders*>(_impl_.request_type_.reqqueryactiveorders_);
}
inline ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* PROTOBUF_NONNULL Request::mutable_reqqueryactiveorders()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryActiveOrders* _msg = _internal_mutable_reqqueryactiveorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryActiveOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryHistoricalOrders reqQueryHistoricalOrders = 21;
inline bool Request::has_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders;
}
inline bool Request::_internal_has_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders;
}
inline void Request::set_has_reqqueryhistoricalorders() {
  _impl_._oneof_case_[0] = kReqQueryHistoricalOrders;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE Request::release_reqqueryhistoricalorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  if (request_type_case() == kReqQueryHistoricalOrders) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders*>(_impl_.request_type_.reqqueryhistoricalorders_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryhistoricalorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& Request::_internal_reqqueryhistoricalorders() const {
  return request_type_case() == kReqQueryHistoricalOrders ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders*>(_impl_.request_type_.reqqueryhistoricalorders_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders&>(::lampyris::crypto::protocol::trading::_ReqQueryHistoricalOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders& Request::reqqueryhistoricalorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  return _internal_reqqueryhistoricalorders();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqqueryhistoricalorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  if (request_type_case() == kReqQueryHistoricalOrders) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders*>(_impl_.request_type_.reqqueryhistoricalorders_);
    _impl_.request_type_.reqqueryhistoricalorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryhistoricalorders(
    ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryhistoricalorders();
    _impl_.request_type_.reqqueryhistoricalorders_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NONNULL Request::_internal_mutable_reqqueryhistoricalorders() {
  if (request_type_case() != kReqQueryHistoricalOrders) {
    clear_request_type();
    set_has_reqqueryhistoricalorders();
    _impl_.request_type_.reqqueryhistoricalorders_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders*>(_impl_.request_type_.reqqueryhistoricalorders_);
}
inline ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* PROTOBUF_NONNULL Request::mutable_reqqueryhistoricalorders()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryHistoricalOrders* _msg = _internal_mutable_reqqueryhistoricalorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryHistoricalOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryPositions reqQueryPositions = 22;
inline bool Request::has_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions;
}
inline bool Request::_internal_has_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions;
}
inline void Request::set_has_reqquerypositions() {
  _impl_._oneof_case_[0] = kReqQueryPositions;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE Request::release_reqquerypositions() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  if (request_type_case() == kReqQueryPositions) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions*>(_impl_.request_type_.reqquerypositions_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryPositions& Request::_internal_reqquerypositions() const {
  return request_type_case() == kReqQueryPositions ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions*>(_impl_.request_type_.reqquerypositions_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions&>(::lampyris::crypto::protocol::trading::_ReqQueryPositions_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryPositions& Request::reqquerypositions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  return _internal_reqquerypositions();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqquerypositions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  if (request_type_case() == kReqQueryPositions) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions*>(_impl_.request_type_.reqquerypositions_);
    _impl_.request_type_.reqquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqquerypositions(
    ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqquerypositions();
    _impl_.request_type_.reqquerypositions_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryPositions)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NONNULL Request::_internal_mutable_reqquerypositions() {
  if (request_type_case() != kReqQueryPositions) {
    clear_request_type();
    set_has_reqquerypositions();
    _impl_.request_type_.reqquerypositions_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryPositions>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryPositions*>(_impl_.request_type_.reqquerypositions_);
}
inline ::lampyris::crypto::protocol::trading::ReqQueryPositions* PROTOBUF_NONNULL Request::mutable_reqquerypositions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryPositions* _msg = _internal_mutable_reqquerypositions();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryPositions)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqSetLeverage reqSetLeverage = 23;
inline bool Request::has_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage;
}
inline bool Request::_internal_has_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage;
}
inline void Request::set_has_reqsetleverage() {
  _impl_._oneof_case_[0] = kReqSetLeverage;
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE Request::release_reqsetleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  if (request_type_case() == kReqSetLeverage) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage*>(_impl_.request_type_.reqsetleverage_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqsetleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqSetLeverage& Request::_internal_reqsetleverage() const {
  return request_type_case() == kReqSetLeverage ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage*>(_impl_.request_type_.reqsetleverage_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage&>(::lampyris::crypto::protocol::trading::_ReqSetLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqSetLeverage& Request::reqsetleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  return _internal_reqsetleverage();
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqsetleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  if (request_type_case() == kReqSetLeverage) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage*>(_impl_.request_type_.reqsetleverage_);
    _impl_.request_type_.reqsetleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqsetleverage(
    ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqsetleverage();
    _impl_.request_type_.reqsetleverage_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqSetLeverage)
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NONNULL Request::_internal_mutable_reqsetleverage() {
  if (request_type_case() != kReqSetLeverage) {
    clear_request_type();
    set_has_reqsetleverage();
    _impl_.request_type_.reqsetleverage_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqSetLeverage>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqSetLeverage*>(_impl_.request_type_.reqsetleverage_);
}
inline ::lampyris::crypto::protocol::trading::ReqSetLeverage* PROTOBUF_NONNULL Request::mutable_reqsetleverage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqSetLeverage* _msg = _internal_mutable_reqsetleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqSetLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryLeverage reqQueryLeverage = 24;
inline bool Request::has_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage;
}
inline bool Request::_internal_has_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage;
}
inline void Request::set_has_reqqueryleverage() {
  _impl_._oneof_case_[0] = kReqQueryLeverage;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE Request::release_reqqueryleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  if (request_type_case() == kReqQueryLeverage) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage*>(_impl_.request_type_.reqqueryleverage_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& Request::_internal_reqqueryleverage() const {
  return request_type_case() == kReqQueryLeverage ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage*>(_impl_.request_type_.reqqueryleverage_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage&>(::lampyris::crypto::protocol::trading::_ReqQueryLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverage& Request::reqqueryleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  return _internal_reqqueryleverage();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqqueryleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  if (request_type_case() == kReqQueryLeverage) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage*>(_impl_.request_type_.reqqueryleverage_);
    _impl_.request_type_.reqqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryleverage(
    ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryleverage();
    _impl_.request_type_.reqqueryleverage_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NONNULL Request::_internal_mutable_reqqueryleverage() {
  if (request_type_case() != kReqQueryLeverage) {
    clear_request_type();
    set_has_reqqueryleverage();
    _impl_.request_type_.reqqueryleverage_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryLeverage>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverage*>(_impl_.request_type_.reqqueryleverage_);
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverage* PROTOBUF_NONNULL Request::mutable_reqqueryleverage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryLeverage* _msg = _internal_mutable_reqqueryleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ReqQueryLeverageBracket reqQueryLeverageBracket = 25;
inline bool Request::has_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket;
}
inline bool Request::_internal_has_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket;
}
inline void Request::set_has_reqqueryleveragebracket() {
  _impl_._oneof_case_[0] = kReqQueryLeverageBracket;
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE Request::release_reqqueryleveragebracket() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  if (request_type_case() == kReqQueryLeverageBracket) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket*>(_impl_.request_type_.reqqueryleveragebracket_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.reqqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& Request::_internal_reqqueryleveragebracket() const {
  return request_type_case() == kReqQueryLeverageBracket ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket*>(_impl_.request_type_.reqqueryleveragebracket_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket&>(::lampyris::crypto::protocol::trading::_ReqQueryLeverageBracket_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket& Request::reqqueryleveragebracket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  return _internal_reqqueryleveragebracket();
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE Request::unsafe_arena_release_reqqueryleveragebracket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  if (request_type_case() == kReqQueryLeverageBracket) {
    clear_has_request_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket*>(_impl_.request_type_.reqqueryleveragebracket_);
    _impl_.request_type_.reqqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_reqqueryleveragebracket(
    ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request_type();
  if (value) {
    set_has_reqqueryleveragebracket();
    _impl_.request_type_.reqqueryleveragebracket_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NONNULL Request::_internal_mutable_reqqueryleveragebracket() {
  if (request_type_case() != kReqQueryLeverageBracket) {
    clear_request_type();
    set_has_reqqueryleveragebracket();
    _impl_.request_type_.reqqueryleveragebracket_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket*>(_impl_.request_type_.reqqueryleveragebracket_);
}
inline ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* PROTOBUF_NONNULL Request::mutable_reqqueryleveragebracket()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ReqQueryLeverageBracket* _msg = _internal_mutable_reqqueryleveragebracket();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Request.reqQueryLeverageBracket)
  return _msg;
}

inline bool Request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void Request::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::request_type_case() const {
  return Request::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .lampyris.crypto.protocol.account.AccountAssetInfoBean accountAssetInfoBean = 1;
inline bool Response::has_accountassetinfobean() const {
  return response_type_case() == kAccountAssetInfoBean;
}
inline bool Response::_internal_has_accountassetinfobean() const {
  return response_type_case() == kAccountAssetInfoBean;
}
inline void Response::set_has_accountassetinfobean() {
  _impl_._oneof_case_[0] = kAccountAssetInfoBean;
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE Response::release_accountassetinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  if (response_type_case() == kAccountAssetInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::AccountAssetInfoBean*>(_impl_.response_type_.accountassetinfobean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.accountassetinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& Response::_internal_accountassetinfobean() const {
  return response_type_case() == kAccountAssetInfoBean ? *reinterpret_cast<::lampyris::crypto::protocol::account::AccountAssetInfoBean*>(_impl_.response_type_.accountassetinfobean_) : reinterpret_cast<::lampyris::crypto::protocol::account::AccountAssetInfoBean&>(::lampyris::crypto::protocol::account::_AccountAssetInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::AccountAssetInfoBean& Response::accountassetinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  return _internal_accountassetinfobean();
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_accountassetinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  if (response_type_case() == kAccountAssetInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::AccountAssetInfoBean*>(_impl_.response_type_.accountassetinfobean_);
    _impl_.response_type_.accountassetinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_accountassetinfobean(
    ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_accountassetinfobean();
    _impl_.response_type_.accountassetinfobean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NONNULL Response::_internal_mutable_accountassetinfobean() {
  if (response_type_case() != kAccountAssetInfoBean) {
    clear_response_type();
    set_has_accountassetinfobean();
    _impl_.response_type_.accountassetinfobean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::AccountAssetInfoBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::AccountAssetInfoBean*>(_impl_.response_type_.accountassetinfobean_);
}
inline ::lampyris::crypto::protocol::account::AccountAssetInfoBean* PROTOBUF_NONNULL Response::mutable_accountassetinfobean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::AccountAssetInfoBean* _msg = _internal_mutable_accountassetinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.accountAssetInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.account.SubAccountInfoBean subAccountInfoBean = 2;
inline bool Response::has_subaccountinfobean() const {
  return response_type_case() == kSubAccountInfoBean;
}
inline bool Response::_internal_has_subaccountinfobean() const {
  return response_type_case() == kSubAccountInfoBean;
}
inline void Response::set_has_subaccountinfobean() {
  _impl_._oneof_case_[0] = kSubAccountInfoBean;
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE Response::release_subaccountinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  if (response_type_case() == kSubAccountInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::SubAccountInfoBean*>(_impl_.response_type_.subaccountinfobean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.subaccountinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::SubAccountInfoBean& Response::_internal_subaccountinfobean() const {
  return response_type_case() == kSubAccountInfoBean ? *reinterpret_cast<::lampyris::crypto::protocol::account::SubAccountInfoBean*>(_impl_.response_type_.subaccountinfobean_) : reinterpret_cast<::lampyris::crypto::protocol::account::SubAccountInfoBean&>(::lampyris::crypto::protocol::account::_SubAccountInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::SubAccountInfoBean& Response::subaccountinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  return _internal_subaccountinfobean();
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_subaccountinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  if (response_type_case() == kSubAccountInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::SubAccountInfoBean*>(_impl_.response_type_.subaccountinfobean_);
    _impl_.response_type_.subaccountinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_subaccountinfobean(
    ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_subaccountinfobean();
    _impl_.response_type_.subaccountinfobean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NONNULL Response::_internal_mutable_subaccountinfobean() {
  if (response_type_case() != kSubAccountInfoBean) {
    clear_response_type();
    set_has_subaccountinfobean();
    _impl_.response_type_.subaccountinfobean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::SubAccountInfoBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::SubAccountInfoBean*>(_impl_.response_type_.subaccountinfobean_);
}
inline ::lampyris::crypto::protocol::account::SubAccountInfoBean* PROTOBUF_NONNULL Response::mutable_subaccountinfobean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::SubAccountInfoBean* _msg = _internal_mutable_subaccountinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.subAccountInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.account.ResQuerySubAcccountList resQuerySubAcccountList = 3;
inline bool Response::has_resquerysubacccountlist() const {
  return response_type_case() == kResQuerySubAcccountList;
}
inline bool Response::_internal_has_resquerysubacccountlist() const {
  return response_type_case() == kResQuerySubAcccountList;
}
inline void Response::set_has_resquerysubacccountlist() {
  _impl_._oneof_case_[0] = kResQuerySubAcccountList;
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE Response::release_resquerysubacccountlist() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  if (response_type_case() == kResQuerySubAcccountList) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ResQuerySubAcccountList*>(_impl_.response_type_.resquerysubacccountlist_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerysubacccountlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& Response::_internal_resquerysubacccountlist() const {
  return response_type_case() == kResQuerySubAcccountList ? *reinterpret_cast<::lampyris::crypto::protocol::account::ResQuerySubAcccountList*>(_impl_.response_type_.resquerysubacccountlist_) : reinterpret_cast<::lampyris::crypto::protocol::account::ResQuerySubAcccountList&>(::lampyris::crypto::protocol::account::_ResQuerySubAcccountList_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ResQuerySubAcccountList& Response::resquerysubacccountlist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  return _internal_resquerysubacccountlist();
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE Response::unsafe_arena_release_resquerysubacccountlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  if (response_type_case() == kResQuerySubAcccountList) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ResQuerySubAcccountList*>(_impl_.response_type_.resquerysubacccountlist_);
    _impl_.response_type_.resquerysubacccountlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerysubacccountlist(
    ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerysubacccountlist();
    _impl_.response_type_.resquerysubacccountlist_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NONNULL Response::_internal_mutable_resquerysubacccountlist() {
  if (response_type_case() != kResQuerySubAcccountList) {
    clear_response_type();
    set_has_resquerysubacccountlist();
    _impl_.response_type_.resquerysubacccountlist_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ResQuerySubAcccountList>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::ResQuerySubAcccountList*>(_impl_.response_type_.resquerysubacccountlist_);
}
inline ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* PROTOBUF_NONNULL Response::mutable_resquerysubacccountlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ResQuerySubAcccountList* _msg = _internal_mutable_resquerysubacccountlist();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQuerySubAcccountList)
  return _msg;
}

// .lampyris.crypto.protocol.account.ResAccountSummaryUpdate resAccountSummaryUpdate = 4;
inline bool Response::has_resaccountsummaryupdate() const {
  return response_type_case() == kResAccountSummaryUpdate;
}
inline bool Response::_internal_has_resaccountsummaryupdate() const {
  return response_type_case() == kResAccountSummaryUpdate;
}
inline void Response::set_has_resaccountsummaryupdate() {
  _impl_._oneof_case_[0] = kResAccountSummaryUpdate;
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE Response::release_resaccountsummaryupdate() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  if (response_type_case() == kResAccountSummaryUpdate) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate*>(_impl_.response_type_.resaccountsummaryupdate_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& Response::_internal_resaccountsummaryupdate() const {
  return response_type_case() == kResAccountSummaryUpdate ? *reinterpret_cast<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate*>(_impl_.response_type_.resaccountsummaryupdate_) : reinterpret_cast<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate&>(::lampyris::crypto::protocol::account::_ResAccountSummaryUpdate_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate& Response::resaccountsummaryupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  return _internal_resaccountsummaryupdate();
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE Response::unsafe_arena_release_resaccountsummaryupdate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  if (response_type_case() == kResAccountSummaryUpdate) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate*>(_impl_.response_type_.resaccountsummaryupdate_);
    _impl_.response_type_.resaccountsummaryupdate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resaccountsummaryupdate(
    ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resaccountsummaryupdate();
    _impl_.response_type_.resaccountsummaryupdate_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NONNULL Response::_internal_mutable_resaccountsummaryupdate() {
  if (response_type_case() != kResAccountSummaryUpdate) {
    clear_response_type();
    set_has_resaccountsummaryupdate();
    _impl_.response_type_.resaccountsummaryupdate_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::ResAccountSummaryUpdate*>(_impl_.response_type_.resaccountsummaryupdate_);
}
inline ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* PROTOBUF_NONNULL Response::mutable_resaccountsummaryupdate()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::ResAccountSummaryUpdate* _msg = _internal_mutable_resaccountsummaryupdate();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resAccountSummaryUpdate)
  return _msg;
}

// .lampyris.crypto.protocol.account.AssetTransferHistoryInfoDetailBean assetTransferHistoryInfoDetailBean = 5;
inline bool Response::has_assettransferhistoryinfodetailbean() const {
  return response_type_case() == kAssetTransferHistoryInfoDetailBean;
}
inline bool Response::_internal_has_assettransferhistoryinfodetailbean() const {
  return response_type_case() == kAssetTransferHistoryInfoDetailBean;
}
inline void Response::set_has_assettransferhistoryinfodetailbean() {
  _impl_._oneof_case_[0] = kAssetTransferHistoryInfoDetailBean;
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE Response::release_assettransferhistoryinfodetailbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  if (response_type_case() == kAssetTransferHistoryInfoDetailBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean*>(_impl_.response_type_.assettransferhistoryinfodetailbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& Response::_internal_assettransferhistoryinfodetailbean() const {
  return response_type_case() == kAssetTransferHistoryInfoDetailBean ? *reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean*>(_impl_.response_type_.assettransferhistoryinfodetailbean_) : reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean&>(::lampyris::crypto::protocol::account::_AssetTransferHistoryInfoDetailBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean& Response::assettransferhistoryinfodetailbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  return _internal_assettransferhistoryinfodetailbean();
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_assettransferhistoryinfodetailbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  if (response_type_case() == kAssetTransferHistoryInfoDetailBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean*>(_impl_.response_type_.assettransferhistoryinfodetailbean_);
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_assettransferhistoryinfodetailbean(
    ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_assettransferhistoryinfodetailbean();
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NONNULL Response::_internal_mutable_assettransferhistoryinfodetailbean() {
  if (response_type_case() != kAssetTransferHistoryInfoDetailBean) {
    clear_response_type();
    set_has_assettransferhistoryinfodetailbean();
    _impl_.response_type_.assettransferhistoryinfodetailbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean*>(_impl_.response_type_.assettransferhistoryinfodetailbean_);
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* PROTOBUF_NONNULL Response::mutable_assettransferhistoryinfodetailbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoDetailBean* _msg = _internal_mutable_assettransferhistoryinfodetailbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoDetailBean)
  return _msg;
}

// .lampyris.crypto.protocol.account.AssetTransferHistoryInfoBean assetTransferHistoryInfoBean = 6;
inline bool Response::has_assettransferhistoryinfobean() const {
  return response_type_case() == kAssetTransferHistoryInfoBean;
}
inline bool Response::_internal_has_assettransferhistoryinfobean() const {
  return response_type_case() == kAssetTransferHistoryInfoBean;
}
inline void Response::set_has_assettransferhistoryinfobean() {
  _impl_._oneof_case_[0] = kAssetTransferHistoryInfoBean;
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE Response::release_assettransferhistoryinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  if (response_type_case() == kAssetTransferHistoryInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean*>(_impl_.response_type_.assettransferhistoryinfobean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.assettransferhistoryinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& Response::_internal_assettransferhistoryinfobean() const {
  return response_type_case() == kAssetTransferHistoryInfoBean ? *reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean*>(_impl_.response_type_.assettransferhistoryinfobean_) : reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean&>(::lampyris::crypto::protocol::account::_AssetTransferHistoryInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean& Response::assettransferhistoryinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  return _internal_assettransferhistoryinfobean();
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_assettransferhistoryinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  if (response_type_case() == kAssetTransferHistoryInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean*>(_impl_.response_type_.assettransferhistoryinfobean_);
    _impl_.response_type_.assettransferhistoryinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_assettransferhistoryinfobean(
    ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_assettransferhistoryinfobean();
    _impl_.response_type_.assettransferhistoryinfobean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NONNULL Response::_internal_mutable_assettransferhistoryinfobean() {
  if (response_type_case() != kAssetTransferHistoryInfoBean) {
    clear_response_type();
    set_has_assettransferhistoryinfobean();
    _impl_.response_type_.assettransferhistoryinfobean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean*>(_impl_.response_type_.assettransferhistoryinfobean_);
}
inline ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* PROTOBUF_NONNULL Response::mutable_assettransferhistoryinfobean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::account::AssetTransferHistoryInfoBean* _msg = _internal_mutable_assettransferhistoryinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.assetTransferHistoryInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResLogin resLogin = 7;
inline bool Response::has_reslogin() const {
  return response_type_case() == kResLogin;
}
inline bool Response::_internal_has_reslogin() const {
  return response_type_case() == kResLogin;
}
inline void Response::set_has_reslogin() {
  _impl_._oneof_case_[0] = kResLogin;
}
inline ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE Response::release_reslogin() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resLogin)
  if (response_type_case() == kResLogin) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ResLogin*>(_impl_.response_type_.reslogin_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.reslogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResLogin& Response::_internal_reslogin() const {
  return response_type_case() == kResLogin ? *reinterpret_cast<::lampyris::crypto::protocol::app::ResLogin*>(_impl_.response_type_.reslogin_) : reinterpret_cast<::lampyris::crypto::protocol::app::ResLogin&>(::lampyris::crypto::protocol::app::_ResLogin_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResLogin& Response::reslogin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resLogin)
  return _internal_reslogin();
}
inline ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE Response::unsafe_arena_release_reslogin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resLogin)
  if (response_type_case() == kResLogin) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ResLogin*>(_impl_.response_type_.reslogin_);
    _impl_.response_type_.reslogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_reslogin(
    ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_reslogin();
    _impl_.response_type_.reslogin_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resLogin)
}
inline ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NONNULL Response::_internal_mutable_reslogin() {
  if (response_type_case() != kResLogin) {
    clear_response_type();
    set_has_reslogin();
    _impl_.response_type_.reslogin_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResLogin>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ResLogin*>(_impl_.response_type_.reslogin_);
}
inline ::lampyris::crypto::protocol::app::ResLogin* PROTOBUF_NONNULL Response::mutable_reslogin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResLogin* _msg = _internal_mutable_reslogin();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resLogin)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResHeartBeat resHeartBeat = 8;
inline bool Response::has_resheartbeat() const {
  return response_type_case() == kResHeartBeat;
}
inline bool Response::_internal_has_resheartbeat() const {
  return response_type_case() == kResHeartBeat;
}
inline void Response::set_has_resheartbeat() {
  _impl_._oneof_case_[0] = kResHeartBeat;
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE Response::release_resheartbeat() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resHeartBeat)
  if (response_type_case() == kResHeartBeat) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat*>(_impl_.response_type_.resheartbeat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResHeartBeat& Response::_internal_resheartbeat() const {
  return response_type_case() == kResHeartBeat ? *reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat*>(_impl_.response_type_.resheartbeat_) : reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat&>(::lampyris::crypto::protocol::app::_ResHeartBeat_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResHeartBeat& Response::resheartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resHeartBeat)
  return _internal_resheartbeat();
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE Response::unsafe_arena_release_resheartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resHeartBeat)
  if (response_type_case() == kResHeartBeat) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat*>(_impl_.response_type_.resheartbeat_);
    _impl_.response_type_.resheartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resheartbeat(
    ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resheartbeat();
    _impl_.response_type_.resheartbeat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resHeartBeat)
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NONNULL Response::_internal_mutable_resheartbeat() {
  if (response_type_case() != kResHeartBeat) {
    clear_response_type();
    set_has_resheartbeat();
    _impl_.response_type_.resheartbeat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResHeartBeat>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ResHeartBeat*>(_impl_.response_type_.resheartbeat_);
}
inline ::lampyris::crypto::protocol::app::ResHeartBeat* PROTOBUF_NONNULL Response::mutable_resheartbeat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResHeartBeat* _msg = _internal_mutable_resheartbeat();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resHeartBeat)
  return _msg;
}

// .lampyris.crypto.protocol.app.ResNotice resNotice = 9;
inline bool Response::has_resnotice() const {
  return response_type_case() == kResNotice;
}
inline bool Response::_internal_has_resnotice() const {
  return response_type_case() == kResNotice;
}
inline void Response::set_has_resnotice() {
  _impl_._oneof_case_[0] = kResNotice;
}
inline ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE Response::release_resnotice() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resNotice)
  if (response_type_case() == kResNotice) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ResNotice*>(_impl_.response_type_.resnotice_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resnotice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::app::ResNotice& Response::_internal_resnotice() const {
  return response_type_case() == kResNotice ? *reinterpret_cast<::lampyris::crypto::protocol::app::ResNotice*>(_impl_.response_type_.resnotice_) : reinterpret_cast<::lampyris::crypto::protocol::app::ResNotice&>(::lampyris::crypto::protocol::app::_ResNotice_default_instance_);
}
inline const ::lampyris::crypto::protocol::app::ResNotice& Response::resnotice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resNotice)
  return _internal_resnotice();
}
inline ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE Response::unsafe_arena_release_resnotice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resNotice)
  if (response_type_case() == kResNotice) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::app::ResNotice*>(_impl_.response_type_.resnotice_);
    _impl_.response_type_.resnotice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resnotice(
    ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resnotice();
    _impl_.response_type_.resnotice_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resNotice)
}
inline ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NONNULL Response::_internal_mutable_resnotice() {
  if (response_type_case() != kResNotice) {
    clear_response_type();
    set_has_resnotice();
    _impl_.response_type_.resnotice_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::app::ResNotice>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::app::ResNotice*>(_impl_.response_type_.resnotice_);
}
inline ::lampyris::crypto::protocol::app::ResNotice* PROTOBUF_NONNULL Response::mutable_resnotice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::app::ResNotice* _msg = _internal_mutable_resnotice();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resNotice)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SymbolTickerDataBean symbolTickerDataBean = 10;
inline bool Response::has_symboltickerdatabean() const {
  return response_type_case() == kSymbolTickerDataBean;
}
inline bool Response::_internal_has_symboltickerdatabean() const {
  return response_type_case() == kSymbolTickerDataBean;
}
inline void Response::set_has_symboltickerdatabean() {
  _impl_._oneof_case_[0] = kSymbolTickerDataBean;
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE Response::release_symboltickerdatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  if (response_type_case() == kSymbolTickerDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTickerDataBean*>(_impl_.response_type_.symboltickerdatabean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symboltickerdatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& Response::_internal_symboltickerdatabean() const {
  return response_type_case() == kSymbolTickerDataBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTickerDataBean*>(_impl_.response_type_.symboltickerdatabean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTickerDataBean&>(::lampyris::crypto::protocol::quote::_SymbolTickerDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SymbolTickerDataBean& Response::symboltickerdatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  return _internal_symboltickerdatabean();
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_symboltickerdatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  if (response_type_case() == kSymbolTickerDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTickerDataBean*>(_impl_.response_type_.symboltickerdatabean_);
    _impl_.response_type_.symboltickerdatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symboltickerdatabean(
    ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symboltickerdatabean();
    _impl_.response_type_.symboltickerdatabean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NONNULL Response::_internal_mutable_symboltickerdatabean() {
  if (response_type_case() != kSymbolTickerDataBean) {
    clear_response_type();
    set_has_symboltickerdatabean();
    _impl_.response_type_.symboltickerdatabean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SymbolTickerDataBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTickerDataBean*>(_impl_.response_type_.symboltickerdatabean_);
}
inline ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* PROTOBUF_NONNULL Response::mutable_symboltickerdatabean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SymbolTickerDataBean* _msg = _internal_mutable_symboltickerdatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolTickerDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResSubscribeTickerData resSubscribeTickerData = 11;
inline bool Response::has_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData;
}
inline bool Response::_internal_has_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData;
}
inline void Response::set_has_ressubscribetickerdata() {
  _impl_._oneof_case_[0] = kResSubscribeTickerData;
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE Response::release_ressubscribetickerdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  if (response_type_case() == kResSubscribeTickerData) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData*>(_impl_.response_type_.ressubscribetickerdata_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.ressubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& Response::_internal_ressubscribetickerdata() const {
  return response_type_case() == kResSubscribeTickerData ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData*>(_impl_.response_type_.ressubscribetickerdata_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData&>(::lampyris::crypto::protocol::quote::_ResSubscribeTickerData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResSubscribeTickerData& Response::ressubscribetickerdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  return _internal_ressubscribetickerdata();
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE Response::unsafe_arena_release_ressubscribetickerdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  if (response_type_case() == kResSubscribeTickerData) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData*>(_impl_.response_type_.ressubscribetickerdata_);
    _impl_.response_type_.ressubscribetickerdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_ressubscribetickerdata(
    ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_ressubscribetickerdata();
    _impl_.response_type_.ressubscribetickerdata_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NONNULL Response::_internal_mutable_ressubscribetickerdata() {
  if (response_type_case() != kResSubscribeTickerData) {
    clear_response_type();
    set_has_ressubscribetickerdata();
    _impl_.response_type_.ressubscribetickerdata_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResSubscribeTickerData>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ResSubscribeTickerData*>(_impl_.response_type_.ressubscribetickerdata_);
}
inline ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* PROTOBUF_NONNULL Response::mutable_ressubscribetickerdata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResSubscribeTickerData* _msg = _internal_mutable_ressubscribetickerdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resSubscribeTickerData)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SymbolTradeDataBean symbolTradeDataBean = 12;
inline bool Response::has_symboltradedatabean() const {
  return response_type_case() == kSymbolTradeDataBean;
}
inline bool Response::_internal_has_symboltradedatabean() const {
  return response_type_case() == kSymbolTradeDataBean;
}
inline void Response::set_has_symboltradedatabean() {
  _impl_._oneof_case_[0] = kSymbolTradeDataBean;
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE Response::release_symboltradedatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  if (response_type_case() == kSymbolTradeDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeDataBean*>(_impl_.response_type_.symboltradedatabean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symboltradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& Response::_internal_symboltradedatabean() const {
  return response_type_case() == kSymbolTradeDataBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeDataBean*>(_impl_.response_type_.symboltradedatabean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeDataBean&>(::lampyris::crypto::protocol::quote::_SymbolTradeDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeDataBean& Response::symboltradedatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  return _internal_symboltradedatabean();
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_symboltradedatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  if (response_type_case() == kSymbolTradeDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeDataBean*>(_impl_.response_type_.symboltradedatabean_);
    _impl_.response_type_.symboltradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symboltradedatabean(
    ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symboltradedatabean();
    _impl_.response_type_.symboltradedatabean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NONNULL Response::_internal_mutable_symboltradedatabean() {
  if (response_type_case() != kSymbolTradeDataBean) {
    clear_response_type();
    set_has_symboltradedatabean();
    _impl_.response_type_.symboltradedatabean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SymbolTradeDataBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeDataBean*>(_impl_.response_type_.symboltradedatabean_);
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* PROTOBUF_NONNULL Response::mutable_symboltradedatabean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SymbolTradeDataBean* _msg = _internal_mutable_symboltradedatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolTradeDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.TradeDataBean tradeDataBean = 13;
inline bool Response::has_tradedatabean() const {
  return response_type_case() == kTradeDataBean;
}
inline bool Response::_internal_has_tradedatabean() const {
  return response_type_case() == kTradeDataBean;
}
inline void Response::set_has_tradedatabean() {
  _impl_._oneof_case_[0] = kTradeDataBean;
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE Response::release_tradedatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.tradeDataBean)
  if (response_type_case() == kTradeDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::TradeDataBean*>(_impl_.response_type_.tradedatabean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.tradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::TradeDataBean& Response::_internal_tradedatabean() const {
  return response_type_case() == kTradeDataBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::TradeDataBean*>(_impl_.response_type_.tradedatabean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::TradeDataBean&>(::lampyris::crypto::protocol::quote::_TradeDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::TradeDataBean& Response::tradedatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.tradeDataBean)
  return _internal_tradedatabean();
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_tradedatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.tradeDataBean)
  if (response_type_case() == kTradeDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::TradeDataBean*>(_impl_.response_type_.tradedatabean_);
    _impl_.response_type_.tradedatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tradedatabean(
    ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_tradedatabean();
    _impl_.response_type_.tradedatabean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.tradeDataBean)
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NONNULL Response::_internal_mutable_tradedatabean() {
  if (response_type_case() != kTradeDataBean) {
    clear_response_type();
    set_has_tradedatabean();
    _impl_.response_type_.tradedatabean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::TradeDataBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::TradeDataBean*>(_impl_.response_type_.tradedatabean_);
}
inline ::lampyris::crypto::protocol::quote::TradeDataBean* PROTOBUF_NONNULL Response::mutable_tradedatabean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::TradeDataBean* _msg = _internal_mutable_tradedatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.tradeDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResCandlestickQuery resCandlestickQuery = 14;
inline bool Response::has_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery;
}
inline bool Response::_internal_has_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery;
}
inline void Response::set_has_rescandlestickquery() {
  _impl_._oneof_case_[0] = kResCandlestickQuery;
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE Response::release_rescandlestickquery() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  if (response_type_case() == kResCandlestickQuery) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery*>(_impl_.response_type_.rescandlestickquery_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.rescandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& Response::_internal_rescandlestickquery() const {
  return response_type_case() == kResCandlestickQuery ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery*>(_impl_.response_type_.rescandlestickquery_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery&>(::lampyris::crypto::protocol::quote::_ResCandlestickQuery_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResCandlestickQuery& Response::rescandlestickquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  return _internal_rescandlestickquery();
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE Response::unsafe_arena_release_rescandlestickquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  if (response_type_case() == kResCandlestickQuery) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery*>(_impl_.response_type_.rescandlestickquery_);
    _impl_.response_type_.rescandlestickquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_rescandlestickquery(
    ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_rescandlestickquery();
    _impl_.response_type_.rescandlestickquery_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NONNULL Response::_internal_mutable_rescandlestickquery() {
  if (response_type_case() != kResCandlestickQuery) {
    clear_response_type();
    set_has_rescandlestickquery();
    _impl_.response_type_.rescandlestickquery_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResCandlestickQuery>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ResCandlestickQuery*>(_impl_.response_type_.rescandlestickquery_);
}
inline ::lampyris::crypto::protocol::quote::ResCandlestickQuery* PROTOBUF_NONNULL Response::mutable_rescandlestickquery()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResCandlestickQuery* _msg = _internal_mutable_rescandlestickquery();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resCandlestickQuery)
  return _msg;
}

// .lampyris.crypto.protocol.quote.CandlestickUpdateBean candlestickUpdateBean = 15;
inline bool Response::has_candlestickupdatebean() const {
  return response_type_case() == kCandlestickUpdateBean;
}
inline bool Response::_internal_has_candlestickupdatebean() const {
  return response_type_case() == kCandlestickUpdateBean;
}
inline void Response::set_has_candlestickupdatebean() {
  _impl_._oneof_case_[0] = kCandlestickUpdateBean;
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE Response::release_candlestickupdatebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  if (response_type_case() == kCandlestickUpdateBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickUpdateBean*>(_impl_.response_type_.candlestickupdatebean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.candlestickupdatebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& Response::_internal_candlestickupdatebean() const {
  return response_type_case() == kCandlestickUpdateBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickUpdateBean*>(_impl_.response_type_.candlestickupdatebean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickUpdateBean&>(::lampyris::crypto::protocol::quote::_CandlestickUpdateBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::CandlestickUpdateBean& Response::candlestickupdatebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  return _internal_candlestickupdatebean();
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_candlestickupdatebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  if (response_type_case() == kCandlestickUpdateBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickUpdateBean*>(_impl_.response_type_.candlestickupdatebean_);
    _impl_.response_type_.candlestickupdatebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_candlestickupdatebean(
    ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_candlestickupdatebean();
    _impl_.response_type_.candlestickupdatebean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NONNULL Response::_internal_mutable_candlestickupdatebean() {
  if (response_type_case() != kCandlestickUpdateBean) {
    clear_response_type();
    set_has_candlestickupdatebean();
    _impl_.response_type_.candlestickupdatebean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::CandlestickUpdateBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickUpdateBean*>(_impl_.response_type_.candlestickupdatebean_);
}
inline ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* PROTOBUF_NONNULL Response::mutable_candlestickupdatebean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::CandlestickUpdateBean* _msg = _internal_mutable_candlestickupdatebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.candlestickUpdateBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.CandlestickBean candlestickBean = 16;
inline bool Response::has_candlestickbean() const {
  return response_type_case() == kCandlestickBean;
}
inline bool Response::_internal_has_candlestickbean() const {
  return response_type_case() == kCandlestickBean;
}
inline void Response::set_has_candlestickbean() {
  _impl_._oneof_case_[0] = kCandlestickBean;
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE Response::release_candlestickbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.candlestickBean)
  if (response_type_case() == kCandlestickBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickBean*>(_impl_.response_type_.candlestickbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.candlestickbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::CandlestickBean& Response::_internal_candlestickbean() const {
  return response_type_case() == kCandlestickBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickBean*>(_impl_.response_type_.candlestickbean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickBean&>(::lampyris::crypto::protocol::quote::_CandlestickBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::CandlestickBean& Response::candlestickbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.candlestickBean)
  return _internal_candlestickbean();
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_candlestickbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.candlestickBean)
  if (response_type_case() == kCandlestickBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickBean*>(_impl_.response_type_.candlestickbean_);
    _impl_.response_type_.candlestickbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_candlestickbean(
    ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_candlestickbean();
    _impl_.response_type_.candlestickbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.candlestickBean)
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NONNULL Response::_internal_mutable_candlestickbean() {
  if (response_type_case() != kCandlestickBean) {
    clear_response_type();
    set_has_candlestickbean();
    _impl_.response_type_.candlestickbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::CandlestickBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::CandlestickBean*>(_impl_.response_type_.candlestickbean_);
}
inline ::lampyris::crypto::protocol::quote::CandlestickBean* PROTOBUF_NONNULL Response::mutable_candlestickbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::CandlestickBean* _msg = _internal_mutable_candlestickbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.candlestickBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResTradeRule resTradeRule = 17;
inline bool Response::has_restraderule() const {
  return response_type_case() == kResTradeRule;
}
inline bool Response::_internal_has_restraderule() const {
  return response_type_case() == kResTradeRule;
}
inline void Response::set_has_restraderule() {
  _impl_._oneof_case_[0] = kResTradeRule;
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE Response::release_restraderule() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resTradeRule)
  if (response_type_case() == kResTradeRule) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule*>(_impl_.response_type_.restraderule_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.restraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResTradeRule& Response::_internal_restraderule() const {
  return response_type_case() == kResTradeRule ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule*>(_impl_.response_type_.restraderule_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule&>(::lampyris::crypto::protocol::quote::_ResTradeRule_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResTradeRule& Response::restraderule() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resTradeRule)
  return _internal_restraderule();
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE Response::unsafe_arena_release_restraderule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resTradeRule)
  if (response_type_case() == kResTradeRule) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule*>(_impl_.response_type_.restraderule_);
    _impl_.response_type_.restraderule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_restraderule(
    ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_restraderule();
    _impl_.response_type_.restraderule_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resTradeRule)
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NONNULL Response::_internal_mutable_restraderule() {
  if (response_type_case() != kResTradeRule) {
    clear_response_type();
    set_has_restraderule();
    _impl_.response_type_.restraderule_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResTradeRule>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ResTradeRule*>(_impl_.response_type_.restraderule_);
}
inline ::lampyris::crypto::protocol::quote::ResTradeRule* PROTOBUF_NONNULL Response::mutable_restraderule()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResTradeRule* _msg = _internal_mutable_restraderule();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resTradeRule)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SymbolTradeRuleBean symbolTradeRuleBean = 18;
inline bool Response::has_symboltraderulebean() const {
  return response_type_case() == kSymbolTradeRuleBean;
}
inline bool Response::_internal_has_symboltraderulebean() const {
  return response_type_case() == kSymbolTradeRuleBean;
}
inline void Response::set_has_symboltraderulebean() {
  _impl_._oneof_case_[0] = kSymbolTradeRuleBean;
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE Response::release_symboltraderulebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  if (response_type_case() == kSymbolTradeRuleBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean*>(_impl_.response_type_.symboltraderulebean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symboltraderulebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& Response::_internal_symboltraderulebean() const {
  return response_type_case() == kSymbolTradeRuleBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean*>(_impl_.response_type_.symboltraderulebean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean&>(::lampyris::crypto::protocol::quote::_SymbolTradeRuleBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean& Response::symboltraderulebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  return _internal_symboltraderulebean();
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_symboltraderulebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  if (response_type_case() == kSymbolTradeRuleBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean*>(_impl_.response_type_.symboltraderulebean_);
    _impl_.response_type_.symboltraderulebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symboltraderulebean(
    ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symboltraderulebean();
    _impl_.response_type_.symboltraderulebean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NONNULL Response::_internal_mutable_symboltraderulebean() {
  if (response_type_case() != kSymbolTradeRuleBean) {
    clear_response_type();
    set_has_symboltraderulebean();
    _impl_.response_type_.symboltraderulebean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::SymbolTradeRuleBean*>(_impl_.response_type_.symboltraderulebean_);
}
inline ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* PROTOBUF_NONNULL Response::mutable_symboltraderulebean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SymbolTradeRuleBean* _msg = _internal_mutable_symboltraderulebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolTradeRuleBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.MarketMonitorNoticeListBean marketMonitorNoticeListBean = 19;
inline bool Response::has_marketmonitornoticelistbean() const {
  return response_type_case() == kMarketMonitorNoticeListBean;
}
inline bool Response::_internal_has_marketmonitornoticelistbean() const {
  return response_type_case() == kMarketMonitorNoticeListBean;
}
inline void Response::set_has_marketmonitornoticelistbean() {
  _impl_._oneof_case_[0] = kMarketMonitorNoticeListBean;
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE Response::release_marketmonitornoticelistbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  if (response_type_case() == kMarketMonitorNoticeListBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean*>(_impl_.response_type_.marketmonitornoticelistbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.marketmonitornoticelistbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& Response::_internal_marketmonitornoticelistbean() const {
  return response_type_case() == kMarketMonitorNoticeListBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean*>(_impl_.response_type_.marketmonitornoticelistbean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean&>(::lampyris::crypto::protocol::quote::_MarketMonitorNoticeListBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean& Response::marketmonitornoticelistbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  return _internal_marketmonitornoticelistbean();
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_marketmonitornoticelistbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  if (response_type_case() == kMarketMonitorNoticeListBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean*>(_impl_.response_type_.marketmonitornoticelistbean_);
    _impl_.response_type_.marketmonitornoticelistbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_marketmonitornoticelistbean(
    ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_marketmonitornoticelistbean();
    _impl_.response_type_.marketmonitornoticelistbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NONNULL Response::_internal_mutable_marketmonitornoticelistbean() {
  if (response_type_case() != kMarketMonitorNoticeListBean) {
    clear_response_type();
    set_has_marketmonitornoticelistbean();
    _impl_.response_type_.marketmonitornoticelistbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean*>(_impl_.response_type_.marketmonitornoticelistbean_);
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* PROTOBUF_NONNULL Response::mutable_marketmonitornoticelistbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeListBean* _msg = _internal_mutable_marketmonitornoticelistbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.marketMonitorNoticeListBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.MarketMonitorNoticeBean marketMonitorNoticeBean = 20;
inline bool Response::has_marketmonitornoticebean() const {
  return response_type_case() == kMarketMonitorNoticeBean;
}
inline bool Response::_internal_has_marketmonitornoticebean() const {
  return response_type_case() == kMarketMonitorNoticeBean;
}
inline void Response::set_has_marketmonitornoticebean() {
  _impl_._oneof_case_[0] = kMarketMonitorNoticeBean;
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE Response::release_marketmonitornoticebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  if (response_type_case() == kMarketMonitorNoticeBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean*>(_impl_.response_type_.marketmonitornoticebean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.marketmonitornoticebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& Response::_internal_marketmonitornoticebean() const {
  return response_type_case() == kMarketMonitorNoticeBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean*>(_impl_.response_type_.marketmonitornoticebean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean&>(::lampyris::crypto::protocol::quote::_MarketMonitorNoticeBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean& Response::marketmonitornoticebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  return _internal_marketmonitornoticebean();
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_marketmonitornoticebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  if (response_type_case() == kMarketMonitorNoticeBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean*>(_impl_.response_type_.marketmonitornoticebean_);
    _impl_.response_type_.marketmonitornoticebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_marketmonitornoticebean(
    ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_marketmonitornoticebean();
    _impl_.response_type_.marketmonitornoticebean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NONNULL Response::_internal_mutable_marketmonitornoticebean() {
  if (response_type_case() != kMarketMonitorNoticeBean) {
    clear_response_type();
    set_has_marketmonitornoticebean();
    _impl_.response_type_.marketmonitornoticebean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean*>(_impl_.response_type_.marketmonitornoticebean_);
}
inline ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* PROTOBUF_NONNULL Response::mutable_marketmonitornoticebean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::MarketMonitorNoticeBean* _msg = _internal_mutable_marketmonitornoticebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.marketMonitorNoticeBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SelfSelectedSymbolInfoBean selfSelectedSymbolInfoBean = 21;
inline bool Response::has_selfselectedsymbolinfobean() const {
  return response_type_case() == kSelfSelectedSymbolInfoBean;
}
inline bool Response::_internal_has_selfselectedsymbolinfobean() const {
  return response_type_case() == kSelfSelectedSymbolInfoBean;
}
inline void Response::set_has_selfselectedsymbolinfobean() {
  _impl_._oneof_case_[0] = kSelfSelectedSymbolInfoBean;
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE Response::release_selfselectedsymbolinfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  if (response_type_case() == kSelfSelectedSymbolInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean*>(_impl_.response_type_.selfselectedsymbolinfobean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.selfselectedsymbolinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& Response::_internal_selfselectedsymbolinfobean() const {
  return response_type_case() == kSelfSelectedSymbolInfoBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean*>(_impl_.response_type_.selfselectedsymbolinfobean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean&>(::lampyris::crypto::protocol::quote::_SelfSelectedSymbolInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean& Response::selfselectedsymbolinfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  return _internal_selfselectedsymbolinfobean();
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_selfselectedsymbolinfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  if (response_type_case() == kSelfSelectedSymbolInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean*>(_impl_.response_type_.selfselectedsymbolinfobean_);
    _impl_.response_type_.selfselectedsymbolinfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_selfselectedsymbolinfobean(
    ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_selfselectedsymbolinfobean();
    _impl_.response_type_.selfselectedsymbolinfobean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NONNULL Response::_internal_mutable_selfselectedsymbolinfobean() {
  if (response_type_case() != kSelfSelectedSymbolInfoBean) {
    clear_response_type();
    set_has_selfselectedsymbolinfobean();
    _impl_.response_type_.selfselectedsymbolinfobean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean*>(_impl_.response_type_.selfselectedsymbolinfobean_);
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* PROTOBUF_NONNULL Response::mutable_selfselectedsymbolinfobean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolInfoBean* _msg = _internal_mutable_selfselectedsymbolinfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.selfSelectedSymbolInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.SelfSelectedSymbolGroupBean selfSelectedSymbolGroupBean = 22;
inline bool Response::has_selfselectedsymbolgroupbean() const {
  return response_type_case() == kSelfSelectedSymbolGroupBean;
}
inline bool Response::_internal_has_selfselectedsymbolgroupbean() const {
  return response_type_case() == kSelfSelectedSymbolGroupBean;
}
inline void Response::set_has_selfselectedsymbolgroupbean() {
  _impl_._oneof_case_[0] = kSelfSelectedSymbolGroupBean;
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE Response::release_selfselectedsymbolgroupbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  if (response_type_case() == kSelfSelectedSymbolGroupBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean*>(_impl_.response_type_.selfselectedsymbolgroupbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.selfselectedsymbolgroupbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& Response::_internal_selfselectedsymbolgroupbean() const {
  return response_type_case() == kSelfSelectedSymbolGroupBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean*>(_impl_.response_type_.selfselectedsymbolgroupbean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean&>(::lampyris::crypto::protocol::quote::_SelfSelectedSymbolGroupBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean& Response::selfselectedsymbolgroupbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  return _internal_selfselectedsymbolgroupbean();
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_selfselectedsymbolgroupbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  if (response_type_case() == kSelfSelectedSymbolGroupBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean*>(_impl_.response_type_.selfselectedsymbolgroupbean_);
    _impl_.response_type_.selfselectedsymbolgroupbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_selfselectedsymbolgroupbean(
    ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_selfselectedsymbolgroupbean();
    _impl_.response_type_.selfselectedsymbolgroupbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NONNULL Response::_internal_mutable_selfselectedsymbolgroupbean() {
  if (response_type_case() != kSelfSelectedSymbolGroupBean) {
    clear_response_type();
    set_has_selfselectedsymbolgroupbean();
    _impl_.response_type_.selfselectedsymbolgroupbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean*>(_impl_.response_type_.selfselectedsymbolgroupbean_);
}
inline ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* PROTOBUF_NONNULL Response::mutable_selfselectedsymbolgroupbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::SelfSelectedSymbolGroupBean* _msg = _internal_mutable_selfselectedsymbolgroupbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.selfSelectedSymbolGroupBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResSelfSelectedSymbol resSelfSelectedSymbol = 23;
inline bool Response::has_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol;
}
inline bool Response::_internal_has_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol;
}
inline void Response::set_has_resselfselectedsymbol() {
  _impl_._oneof_case_[0] = kResSelfSelectedSymbol;
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE Response::release_resselfselectedsymbol() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  if (response_type_case() == kResSelfSelectedSymbol) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol*>(_impl_.response_type_.resselfselectedsymbol_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& Response::_internal_resselfselectedsymbol() const {
  return response_type_case() == kResSelfSelectedSymbol ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol*>(_impl_.response_type_.resselfselectedsymbol_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol&>(::lampyris::crypto::protocol::quote::_ResSelfSelectedSymbol_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol& Response::resselfselectedsymbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  return _internal_resselfselectedsymbol();
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE Response::unsafe_arena_release_resselfselectedsymbol() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  if (response_type_case() == kResSelfSelectedSymbol) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol*>(_impl_.response_type_.resselfselectedsymbol_);
    _impl_.response_type_.resselfselectedsymbol_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resselfselectedsymbol(
    ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resselfselectedsymbol();
    _impl_.response_type_.resselfselectedsymbol_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NONNULL Response::_internal_mutable_resselfselectedsymbol() {
  if (response_type_case() != kResSelfSelectedSymbol) {
    clear_response_type();
    set_has_resselfselectedsymbol();
    _impl_.response_type_.resselfselectedsymbol_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol*>(_impl_.response_type_.resselfselectedsymbol_);
}
inline ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* PROTOBUF_NONNULL Response::mutable_resselfselectedsymbol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResSelfSelectedSymbol* _msg = _internal_mutable_resselfselectedsymbol();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resSelfSelectedSymbol)
  return _msg;
}

// .lampyris.crypto.protocol.quote.MarketPreviewIntervalDataBean marketPreviewIntervalDataBean = 24;
inline bool Response::has_marketpreviewintervaldatabean() const {
  return response_type_case() == kMarketPreviewIntervalDataBean;
}
inline bool Response::_internal_has_marketpreviewintervaldatabean() const {
  return response_type_case() == kMarketPreviewIntervalDataBean;
}
inline void Response::set_has_marketpreviewintervaldatabean() {
  _impl_._oneof_case_[0] = kMarketPreviewIntervalDataBean;
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE Response::release_marketpreviewintervaldatabean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  if (response_type_case() == kMarketPreviewIntervalDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean*>(_impl_.response_type_.marketpreviewintervaldatabean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.marketpreviewintervaldatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& Response::_internal_marketpreviewintervaldatabean() const {
  return response_type_case() == kMarketPreviewIntervalDataBean ? *reinterpret_cast<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean*>(_impl_.response_type_.marketpreviewintervaldatabean_) : reinterpret_cast<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean&>(::lampyris::crypto::protocol::quote::_MarketPreviewIntervalDataBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean& Response::marketpreviewintervaldatabean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  return _internal_marketpreviewintervaldatabean();
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_marketpreviewintervaldatabean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  if (response_type_case() == kMarketPreviewIntervalDataBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean*>(_impl_.response_type_.marketpreviewintervaldatabean_);
    _impl_.response_type_.marketpreviewintervaldatabean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_marketpreviewintervaldatabean(
    ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_marketpreviewintervaldatabean();
    _impl_.response_type_.marketpreviewintervaldatabean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NONNULL Response::_internal_mutable_marketpreviewintervaldatabean() {
  if (response_type_case() != kMarketPreviewIntervalDataBean) {
    clear_response_type();
    set_has_marketpreviewintervaldatabean();
    _impl_.response_type_.marketpreviewintervaldatabean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean*>(_impl_.response_type_.marketpreviewintervaldatabean_);
}
inline ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* PROTOBUF_NONNULL Response::mutable_marketpreviewintervaldatabean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::MarketPreviewIntervalDataBean* _msg = _internal_mutable_marketpreviewintervaldatabean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.marketPreviewIntervalDataBean)
  return _msg;
}

// .lampyris.crypto.protocol.quote.ResMarketPreviewData resMarketPreviewData = 25;
inline bool Response::has_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData;
}
inline bool Response::_internal_has_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData;
}
inline void Response::set_has_resmarketpreviewdata() {
  _impl_._oneof_case_[0] = kResMarketPreviewData;
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE Response::release_resmarketpreviewdata() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  if (response_type_case() == kResMarketPreviewData) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData*>(_impl_.response_type_.resmarketpreviewdata_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resmarketpreviewdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& Response::_internal_resmarketpreviewdata() const {
  return response_type_case() == kResMarketPreviewData ? *reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData*>(_impl_.response_type_.resmarketpreviewdata_) : reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData&>(::lampyris::crypto::protocol::quote::_ResMarketPreviewData_default_instance_);
}
inline const ::lampyris::crypto::protocol::quote::ResMarketPreviewData& Response::resmarketpreviewdata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  return _internal_resmarketpreviewdata();
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE Response::unsafe_arena_release_resmarketpreviewdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  if (response_type_case() == kResMarketPreviewData) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData*>(_impl_.response_type_.resmarketpreviewdata_);
    _impl_.response_type_.resmarketpreviewdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resmarketpreviewdata(
    ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resmarketpreviewdata();
    _impl_.response_type_.resmarketpreviewdata_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NONNULL Response::_internal_mutable_resmarketpreviewdata() {
  if (response_type_case() != kResMarketPreviewData) {
    clear_response_type();
    set_has_resmarketpreviewdata();
    _impl_.response_type_.resmarketpreviewdata_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::quote::ResMarketPreviewData>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::quote::ResMarketPreviewData*>(_impl_.response_type_.resmarketpreviewdata_);
}
inline ::lampyris::crypto::protocol::quote::ResMarketPreviewData* PROTOBUF_NONNULL Response::mutable_resmarketpreviewdata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::quote::ResMarketPreviewData* _msg = _internal_mutable_resmarketpreviewdata();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resMarketPreviewData)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.StreategyConfigBean streategyConfigBean = 26;
inline bool Response::has_streategyconfigbean() const {
  return response_type_case() == kStreategyConfigBean;
}
inline bool Response::_internal_has_streategyconfigbean() const {
  return response_type_case() == kStreategyConfigBean;
}
inline void Response::set_has_streategyconfigbean() {
  _impl_._oneof_case_[0] = kStreategyConfigBean;
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE Response::release_streategyconfigbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  if (response_type_case() == kStreategyConfigBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyConfigBean*>(_impl_.response_type_.streategyconfigbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.streategyconfigbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& Response::_internal_streategyconfigbean() const {
  return response_type_case() == kStreategyConfigBean ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyConfigBean*>(_impl_.response_type_.streategyconfigbean_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyConfigBean&>(::lampyris::crypto::protocol::strategy::_StreategyConfigBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StreategyConfigBean& Response::streategyconfigbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  return _internal_streategyconfigbean();
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_streategyconfigbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  if (response_type_case() == kStreategyConfigBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyConfigBean*>(_impl_.response_type_.streategyconfigbean_);
    _impl_.response_type_.streategyconfigbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_streategyconfigbean(
    ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_streategyconfigbean();
    _impl_.response_type_.streategyconfigbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.streategyConfigBean)
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NONNULL Response::_internal_mutable_streategyconfigbean() {
  if (response_type_case() != kStreategyConfigBean) {
    clear_response_type();
    set_has_streategyconfigbean();
    _impl_.response_type_.streategyconfigbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StreategyConfigBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyConfigBean*>(_impl_.response_type_.streategyconfigbean_);
}
inline ::lampyris::crypto::protocol::strategy::StreategyConfigBean* PROTOBUF_NONNULL Response::mutable_streategyconfigbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StreategyConfigBean* _msg = _internal_mutable_streategyconfigbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.streategyConfigBean)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.StreategyFieldBean streategyFieldBean = 27;
inline bool Response::has_streategyfieldbean() const {
  return response_type_case() == kStreategyFieldBean;
}
inline bool Response::_internal_has_streategyfieldbean() const {
  return response_type_case() == kStreategyFieldBean;
}
inline void Response::set_has_streategyfieldbean() {
  _impl_._oneof_case_[0] = kStreategyFieldBean;
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE Response::release_streategyfieldbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  if (response_type_case() == kStreategyFieldBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyFieldBean*>(_impl_.response_type_.streategyfieldbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.streategyfieldbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& Response::_internal_streategyfieldbean() const {
  return response_type_case() == kStreategyFieldBean ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyFieldBean*>(_impl_.response_type_.streategyfieldbean_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyFieldBean&>(::lampyris::crypto::protocol::strategy::_StreategyFieldBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StreategyFieldBean& Response::streategyfieldbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  return _internal_streategyfieldbean();
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_streategyfieldbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  if (response_type_case() == kStreategyFieldBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyFieldBean*>(_impl_.response_type_.streategyfieldbean_);
    _impl_.response_type_.streategyfieldbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_streategyfieldbean(
    ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_streategyfieldbean();
    _impl_.response_type_.streategyfieldbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.streategyFieldBean)
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NONNULL Response::_internal_mutable_streategyfieldbean() {
  if (response_type_case() != kStreategyFieldBean) {
    clear_response_type();
    set_has_streategyfieldbean();
    _impl_.response_type_.streategyfieldbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StreategyFieldBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::StreategyFieldBean*>(_impl_.response_type_.streategyfieldbean_);
}
inline ::lampyris::crypto::protocol::strategy::StreategyFieldBean* PROTOBUF_NONNULL Response::mutable_streategyfieldbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StreategyFieldBean* _msg = _internal_mutable_streategyfieldbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.streategyFieldBean)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResModifyStreategySetting resModifyStreategySetting = 28;
inline bool Response::has_resmodifystreategysetting() const {
  return response_type_case() == kResModifyStreategySetting;
}
inline bool Response::_internal_has_resmodifystreategysetting() const {
  return response_type_case() == kResModifyStreategySetting;
}
inline void Response::set_has_resmodifystreategysetting() {
  _impl_._oneof_case_[0] = kResModifyStreategySetting;
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE Response::release_resmodifystreategysetting() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  if (response_type_case() == kResModifyStreategySetting) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting*>(_impl_.response_type_.resmodifystreategysetting_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& Response::_internal_resmodifystreategysetting() const {
  return response_type_case() == kResModifyStreategySetting ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting*>(_impl_.response_type_.resmodifystreategysetting_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting&>(::lampyris::crypto::protocol::strategy::_ResModifyStreategySetting_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting& Response::resmodifystreategysetting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  return _internal_resmodifystreategysetting();
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE Response::unsafe_arena_release_resmodifystreategysetting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  if (response_type_case() == kResModifyStreategySetting) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting*>(_impl_.response_type_.resmodifystreategysetting_);
    _impl_.response_type_.resmodifystreategysetting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resmodifystreategysetting(
    ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resmodifystreategysetting();
    _impl_.response_type_.resmodifystreategysetting_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NONNULL Response::_internal_mutable_resmodifystreategysetting() {
  if (response_type_case() != kResModifyStreategySetting) {
    clear_response_type();
    set_has_resmodifystreategysetting();
    _impl_.response_type_.resmodifystreategysetting_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::ResModifyStreategySetting*>(_impl_.response_type_.resmodifystreategysetting_);
}
inline ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* PROTOBUF_NONNULL Response::mutable_resmodifystreategysetting()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResModifyStreategySetting* _msg = _internal_mutable_resmodifystreategysetting();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resModifyStreategySetting)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResStreategySettings resStreategySettings = 29;
inline bool Response::has_resstreategysettings() const {
  return response_type_case() == kResStreategySettings;
}
inline bool Response::_internal_has_resstreategysettings() const {
  return response_type_case() == kResStreategySettings;
}
inline void Response::set_has_resstreategysettings() {
  _impl_._oneof_case_[0] = kResStreategySettings;
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE Response::release_resstreategysettings() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resStreategySettings)
  if (response_type_case() == kResStreategySettings) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStreategySettings*>(_impl_.response_type_.resstreategysettings_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resstreategysettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResStreategySettings& Response::_internal_resstreategysettings() const {
  return response_type_case() == kResStreategySettings ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStreategySettings*>(_impl_.response_type_.resstreategysettings_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStreategySettings&>(::lampyris::crypto::protocol::strategy::_ResStreategySettings_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResStreategySettings& Response::resstreategysettings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resStreategySettings)
  return _internal_resstreategysettings();
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE Response::unsafe_arena_release_resstreategysettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resStreategySettings)
  if (response_type_case() == kResStreategySettings) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStreategySettings*>(_impl_.response_type_.resstreategysettings_);
    _impl_.response_type_.resstreategysettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resstreategysettings(
    ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resstreategysettings();
    _impl_.response_type_.resstreategysettings_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resStreategySettings)
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NONNULL Response::_internal_mutable_resstreategysettings() {
  if (response_type_case() != kResStreategySettings) {
    clear_response_type();
    set_has_resstreategysettings();
    _impl_.response_type_.resstreategysettings_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResStreategySettings>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::ResStreategySettings*>(_impl_.response_type_.resstreategysettings_);
}
inline ::lampyris::crypto::protocol::strategy::ResStreategySettings* PROTOBUF_NONNULL Response::mutable_resstreategysettings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResStreategySettings* _msg = _internal_mutable_resstreategysettings();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resStreategySettings)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.StrategyExectionInfoBean strategyExectionInfoBean = 30;
inline bool Response::has_strategyexectioninfobean() const {
  return response_type_case() == kStrategyExectionInfoBean;
}
inline bool Response::_internal_has_strategyexectioninfobean() const {
  return response_type_case() == kStrategyExectionInfoBean;
}
inline void Response::set_has_strategyexectioninfobean() {
  _impl_._oneof_case_[0] = kStrategyExectionInfoBean;
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE Response::release_strategyexectioninfobean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  if (response_type_case() == kStrategyExectionInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean*>(_impl_.response_type_.strategyexectioninfobean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.strategyexectioninfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& Response::_internal_strategyexectioninfobean() const {
  return response_type_case() == kStrategyExectionInfoBean ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean*>(_impl_.response_type_.strategyexectioninfobean_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean&>(::lampyris::crypto::protocol::strategy::_StrategyExectionInfoBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean& Response::strategyexectioninfobean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  return _internal_strategyexectioninfobean();
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_strategyexectioninfobean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  if (response_type_case() == kStrategyExectionInfoBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean*>(_impl_.response_type_.strategyexectioninfobean_);
    _impl_.response_type_.strategyexectioninfobean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_strategyexectioninfobean(
    ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_strategyexectioninfobean();
    _impl_.response_type_.strategyexectioninfobean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NONNULL Response::_internal_mutable_strategyexectioninfobean() {
  if (response_type_case() != kStrategyExectionInfoBean) {
    clear_response_type();
    set_has_strategyexectioninfobean();
    _impl_.response_type_.strategyexectioninfobean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean*>(_impl_.response_type_.strategyexectioninfobean_);
}
inline ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* PROTOBUF_NONNULL Response::mutable_strategyexectioninfobean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::StrategyExectionInfoBean* _msg = _internal_mutable_strategyexectioninfobean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.strategyExectionInfoBean)
  return _msg;
}

// .lampyris.crypto.protocol.strategy.ResQueryStrategyExectionInfo resQueryStrategyExectionInfo = 31;
inline bool Response::has_resquerystrategyexectioninfo() const {
  return response_type_case() == kResQueryStrategyExectionInfo;
}
inline bool Response::_internal_has_resquerystrategyexectioninfo() const {
  return response_type_case() == kResQueryStrategyExectionInfo;
}
inline void Response::set_has_resquerystrategyexectioninfo() {
  _impl_._oneof_case_[0] = kResQueryStrategyExectionInfo;
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE Response::release_resquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  if (response_type_case() == kResQueryStrategyExectionInfo) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo*>(_impl_.response_type_.resquerystrategyexectioninfo_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& Response::_internal_resquerystrategyexectioninfo() const {
  return response_type_case() == kResQueryStrategyExectionInfo ? *reinterpret_cast<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo*>(_impl_.response_type_.resquerystrategyexectioninfo_) : reinterpret_cast<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo&>(::lampyris::crypto::protocol::strategy::_ResQueryStrategyExectionInfo_default_instance_);
}
inline const ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo& Response::resquerystrategyexectioninfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  return _internal_resquerystrategyexectioninfo();
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE Response::unsafe_arena_release_resquerystrategyexectioninfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  if (response_type_case() == kResQueryStrategyExectionInfo) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo*>(_impl_.response_type_.resquerystrategyexectioninfo_);
    _impl_.response_type_.resquerystrategyexectioninfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerystrategyexectioninfo(
    ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerystrategyexectioninfo();
    _impl_.response_type_.resquerystrategyexectioninfo_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NONNULL Response::_internal_mutable_resquerystrategyexectioninfo() {
  if (response_type_case() != kResQueryStrategyExectionInfo) {
    clear_response_type();
    set_has_resquerystrategyexectioninfo();
    _impl_.response_type_.resquerystrategyexectioninfo_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo*>(_impl_.response_type_.resquerystrategyexectioninfo_);
}
inline ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* PROTOBUF_NONNULL Response::mutable_resquerystrategyexectioninfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::strategy::ResQueryStrategyExectionInfo* _msg = _internal_mutable_resquerystrategyexectioninfo();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryStrategyExectionInfo)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ConditionTriggerBean conditionTriggerBean = 32;
inline bool Response::has_conditiontriggerbean() const {
  return response_type_case() == kConditionTriggerBean;
}
inline bool Response::_internal_has_conditiontriggerbean() const {
  return response_type_case() == kConditionTriggerBean;
}
inline void Response::set_has_conditiontriggerbean() {
  _impl_._oneof_case_[0] = kConditionTriggerBean;
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE Response::release_conditiontriggerbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  if (response_type_case() == kConditionTriggerBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ConditionTriggerBean*>(_impl_.response_type_.conditiontriggerbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.conditiontriggerbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& Response::_internal_conditiontriggerbean() const {
  return response_type_case() == kConditionTriggerBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ConditionTriggerBean*>(_impl_.response_type_.conditiontriggerbean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ConditionTriggerBean&>(::lampyris::crypto::protocol::trading::_ConditionTriggerBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ConditionTriggerBean& Response::conditiontriggerbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  return _internal_conditiontriggerbean();
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_conditiontriggerbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  if (response_type_case() == kConditionTriggerBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ConditionTriggerBean*>(_impl_.response_type_.conditiontriggerbean_);
    _impl_.response_type_.conditiontriggerbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_conditiontriggerbean(
    ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_conditiontriggerbean();
    _impl_.response_type_.conditiontriggerbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NONNULL Response::_internal_mutable_conditiontriggerbean() {
  if (response_type_case() != kConditionTriggerBean) {
    clear_response_type();
    set_has_conditiontriggerbean();
    _impl_.response_type_.conditiontriggerbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ConditionTriggerBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ConditionTriggerBean*>(_impl_.response_type_.conditiontriggerbean_);
}
inline ::lampyris::crypto::protocol::trading::ConditionTriggerBean* PROTOBUF_NONNULL Response::mutable_conditiontriggerbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ConditionTriggerBean* _msg = _internal_mutable_conditiontriggerbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.conditionTriggerBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.OrderBean orderBean = 33;
inline bool Response::has_orderbean() const {
  return response_type_case() == kOrderBean;
}
inline bool Response::_internal_has_orderbean() const {
  return response_type_case() == kOrderBean;
}
inline void Response::set_has_orderbean() {
  _impl_._oneof_case_[0] = kOrderBean;
}
inline ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE Response::release_orderbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.orderBean)
  if (response_type_case() == kOrderBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(_impl_.response_type_.orderbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.orderbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& Response::_internal_orderbean() const {
  return response_type_case() == kOrderBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(_impl_.response_type_.orderbean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean&>(::lampyris::crypto::protocol::trading::_OrderBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderBean& Response::orderbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.orderBean)
  return _internal_orderbean();
}
inline ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_orderbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.orderBean)
  if (response_type_case() == kOrderBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(_impl_.response_type_.orderbean_);
    _impl_.response_type_.orderbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_orderbean(
    ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_orderbean();
    _impl_.response_type_.orderbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.orderBean)
}
inline ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NONNULL Response::_internal_mutable_orderbean() {
  if (response_type_case() != kOrderBean) {
    clear_response_type();
    set_has_orderbean();
    _impl_.response_type_.orderbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::OrderBean*>(_impl_.response_type_.orderbean_);
}
inline ::lampyris::crypto::protocol::trading::OrderBean* PROTOBUF_NONNULL Response::mutable_orderbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::OrderBean* _msg = _internal_mutable_orderbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.orderBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.OrderStatusBean orderStatusBean = 34;
inline bool Response::has_orderstatusbean() const {
  return response_type_case() == kOrderStatusBean;
}
inline bool Response::_internal_has_orderstatusbean() const {
  return response_type_case() == kOrderStatusBean;
}
inline void Response::set_has_orderstatusbean() {
  _impl_._oneof_case_[0] = kOrderStatusBean;
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE Response::release_orderstatusbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.orderStatusBean)
  if (response_type_case() == kOrderStatusBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderStatusBean*>(_impl_.response_type_.orderstatusbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.orderstatusbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::OrderStatusBean& Response::_internal_orderstatusbean() const {
  return response_type_case() == kOrderStatusBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::OrderStatusBean*>(_impl_.response_type_.orderstatusbean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::OrderStatusBean&>(::lampyris::crypto::protocol::trading::_OrderStatusBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::OrderStatusBean& Response::orderstatusbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.orderStatusBean)
  return _internal_orderstatusbean();
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_orderstatusbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.orderStatusBean)
  if (response_type_case() == kOrderStatusBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::OrderStatusBean*>(_impl_.response_type_.orderstatusbean_);
    _impl_.response_type_.orderstatusbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_orderstatusbean(
    ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_orderstatusbean();
    _impl_.response_type_.orderstatusbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.orderStatusBean)
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NONNULL Response::_internal_mutable_orderstatusbean() {
  if (response_type_case() != kOrderStatusBean) {
    clear_response_type();
    set_has_orderstatusbean();
    _impl_.response_type_.orderstatusbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::OrderStatusBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::OrderStatusBean*>(_impl_.response_type_.orderstatusbean_);
}
inline ::lampyris::crypto::protocol::trading::OrderStatusBean* PROTOBUF_NONNULL Response::mutable_orderstatusbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::OrderStatusBean* _msg = _internal_mutable_orderstatusbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.orderStatusBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryOrders resQueryOrders = 35;
inline bool Response::has_resqueryorders() const {
  return response_type_case() == kResQueryOrders;
}
inline bool Response::_internal_has_resqueryorders() const {
  return response_type_case() == kResQueryOrders;
}
inline void Response::set_has_resqueryorders() {
  _impl_._oneof_case_[0] = kResQueryOrders;
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE Response::release_resqueryorders() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryOrders)
  if (response_type_case() == kResQueryOrders) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders*>(_impl_.response_type_.resqueryorders_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryOrders& Response::_internal_resqueryorders() const {
  return response_type_case() == kResQueryOrders ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders*>(_impl_.response_type_.resqueryorders_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders&>(::lampyris::crypto::protocol::trading::_ResQueryOrders_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryOrders& Response::resqueryorders() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryOrders)
  return _internal_resqueryorders();
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE Response::unsafe_arena_release_resqueryorders() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryOrders)
  if (response_type_case() == kResQueryOrders) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders*>(_impl_.response_type_.resqueryorders_);
    _impl_.response_type_.resqueryorders_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryorders(
    ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryorders();
    _impl_.response_type_.resqueryorders_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryOrders)
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NONNULL Response::_internal_mutable_resqueryorders() {
  if (response_type_case() != kResQueryOrders) {
    clear_response_type();
    set_has_resqueryorders();
    _impl_.response_type_.resqueryorders_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryOrders>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryOrders*>(_impl_.response_type_.resqueryorders_);
}
inline ::lampyris::crypto::protocol::trading::ResQueryOrders* PROTOBUF_NONNULL Response::mutable_resqueryorders()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryOrders* _msg = _internal_mutable_resqueryorders();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryOrders)
  return _msg;
}

// .lampyris.crypto.protocol.trading.PositionBean positionBean = 36;
inline bool Response::has_positionbean() const {
  return response_type_case() == kPositionBean;
}
inline bool Response::_internal_has_positionbean() const {
  return response_type_case() == kPositionBean;
}
inline void Response::set_has_positionbean() {
  _impl_._oneof_case_[0] = kPositionBean;
}
inline ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE Response::release_positionbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.positionBean)
  if (response_type_case() == kPositionBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::PositionBean*>(_impl_.response_type_.positionbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.positionbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::PositionBean& Response::_internal_positionbean() const {
  return response_type_case() == kPositionBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::PositionBean*>(_impl_.response_type_.positionbean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::PositionBean&>(::lampyris::crypto::protocol::trading::_PositionBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::PositionBean& Response::positionbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.positionBean)
  return _internal_positionbean();
}
inline ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_positionbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.positionBean)
  if (response_type_case() == kPositionBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::PositionBean*>(_impl_.response_type_.positionbean_);
    _impl_.response_type_.positionbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_positionbean(
    ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_positionbean();
    _impl_.response_type_.positionbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.positionBean)
}
inline ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NONNULL Response::_internal_mutable_positionbean() {
  if (response_type_case() != kPositionBean) {
    clear_response_type();
    set_has_positionbean();
    _impl_.response_type_.positionbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::PositionBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::PositionBean*>(_impl_.response_type_.positionbean_);
}
inline ::lampyris::crypto::protocol::trading::PositionBean* PROTOBUF_NONNULL Response::mutable_positionbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::PositionBean* _msg = _internal_mutable_positionbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.positionBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryPositions resQueryPositions = 37;
inline bool Response::has_resquerypositions() const {
  return response_type_case() == kResQueryPositions;
}
inline bool Response::_internal_has_resquerypositions() const {
  return response_type_case() == kResQueryPositions;
}
inline void Response::set_has_resquerypositions() {
  _impl_._oneof_case_[0] = kResQueryPositions;
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE Response::release_resquerypositions() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryPositions)
  if (response_type_case() == kResQueryPositions) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions*>(_impl_.response_type_.resquerypositions_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryPositions& Response::_internal_resquerypositions() const {
  return response_type_case() == kResQueryPositions ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions*>(_impl_.response_type_.resquerypositions_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions&>(::lampyris::crypto::protocol::trading::_ResQueryPositions_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryPositions& Response::resquerypositions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryPositions)
  return _internal_resquerypositions();
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE Response::unsafe_arena_release_resquerypositions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryPositions)
  if (response_type_case() == kResQueryPositions) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions*>(_impl_.response_type_.resquerypositions_);
    _impl_.response_type_.resquerypositions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resquerypositions(
    ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resquerypositions();
    _impl_.response_type_.resquerypositions_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryPositions)
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NONNULL Response::_internal_mutable_resquerypositions() {
  if (response_type_case() != kResQueryPositions) {
    clear_response_type();
    set_has_resquerypositions();
    _impl_.response_type_.resquerypositions_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryPositions>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryPositions*>(_impl_.response_type_.resquerypositions_);
}
inline ::lampyris::crypto::protocol::trading::ResQueryPositions* PROTOBUF_NONNULL Response::mutable_resquerypositions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryPositions* _msg = _internal_mutable_resquerypositions();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryPositions)
  return _msg;
}

// .lampyris.crypto.protocol.trading.LeverageBean leverageBean = 38;
inline bool Response::has_leveragebean() const {
  return response_type_case() == kLeverageBean;
}
inline bool Response::_internal_has_leveragebean() const {
  return response_type_case() == kLeverageBean;
}
inline void Response::set_has_leveragebean() {
  _impl_._oneof_case_[0] = kLeverageBean;
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE Response::release_leveragebean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.leverageBean)
  if (response_type_case() == kLeverageBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBean*>(_impl_.response_type_.leveragebean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.leveragebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::LeverageBean& Response::_internal_leveragebean() const {
  return response_type_case() == kLeverageBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBean*>(_impl_.response_type_.leveragebean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBean&>(::lampyris::crypto::protocol::trading::_LeverageBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::LeverageBean& Response::leveragebean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.leverageBean)
  return _internal_leveragebean();
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_leveragebean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.leverageBean)
  if (response_type_case() == kLeverageBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBean*>(_impl_.response_type_.leveragebean_);
    _impl_.response_type_.leveragebean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_leveragebean(
    ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_leveragebean();
    _impl_.response_type_.leveragebean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.leverageBean)
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NONNULL Response::_internal_mutable_leveragebean() {
  if (response_type_case() != kLeverageBean) {
    clear_response_type();
    set_has_leveragebean();
    _impl_.response_type_.leveragebean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::LeverageBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBean*>(_impl_.response_type_.leveragebean_);
}
inline ::lampyris::crypto::protocol::trading::LeverageBean* PROTOBUF_NONNULL Response::mutable_leveragebean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::LeverageBean* _msg = _internal_mutable_leveragebean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.leverageBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryLeverage resQueryLeverage = 39;
inline bool Response::has_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage;
}
inline bool Response::_internal_has_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage;
}
inline void Response::set_has_resqueryleverage() {
  _impl_._oneof_case_[0] = kResQueryLeverage;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE Response::release_resqueryleverage() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  if (response_type_case() == kResQueryLeverage) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage*>(_impl_.response_type_.resqueryleverage_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverage& Response::_internal_resqueryleverage() const {
  return response_type_case() == kResQueryLeverage ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage*>(_impl_.response_type_.resqueryleverage_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage&>(::lampyris::crypto::protocol::trading::_ResQueryLeverage_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverage& Response::resqueryleverage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  return _internal_resqueryleverage();
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE Response::unsafe_arena_release_resqueryleverage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  if (response_type_case() == kResQueryLeverage) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage*>(_impl_.response_type_.resqueryleverage_);
    _impl_.response_type_.resqueryleverage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryleverage(
    ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryleverage();
    _impl_.response_type_.resqueryleverage_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryLeverage)
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NONNULL Response::_internal_mutable_resqueryleverage() {
  if (response_type_case() != kResQueryLeverage) {
    clear_response_type();
    set_has_resqueryleverage();
    _impl_.response_type_.resqueryleverage_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryLeverage>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverage*>(_impl_.response_type_.resqueryleverage_);
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverage* PROTOBUF_NONNULL Response::mutable_resqueryleverage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryLeverage* _msg = _internal_mutable_resqueryleverage();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryLeverage)
  return _msg;
}

// .lampyris.crypto.protocol.trading.ResQueryLeverageBracket resQueryLeverageBracket = 40;
inline bool Response::has_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket;
}
inline bool Response::_internal_has_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket;
}
inline void Response::set_has_resqueryleveragebracket() {
  _impl_._oneof_case_[0] = kResQueryLeverageBracket;
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE Response::release_resqueryleveragebracket() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  if (response_type_case() == kResQueryLeverageBracket) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket*>(_impl_.response_type_.resqueryleveragebracket_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.resqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& Response::_internal_resqueryleveragebracket() const {
  return response_type_case() == kResQueryLeverageBracket ? *reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket*>(_impl_.response_type_.resqueryleveragebracket_) : reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket&>(::lampyris::crypto::protocol::trading::_ResQueryLeverageBracket_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket& Response::resqueryleveragebracket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  return _internal_resqueryleveragebracket();
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE Response::unsafe_arena_release_resqueryleveragebracket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  if (response_type_case() == kResQueryLeverageBracket) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket*>(_impl_.response_type_.resqueryleveragebracket_);
    _impl_.response_type_.resqueryleveragebracket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_resqueryleveragebracket(
    ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_resqueryleveragebracket();
    _impl_.response_type_.resqueryleveragebracket_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NONNULL Response::_internal_mutable_resqueryleveragebracket() {
  if (response_type_case() != kResQueryLeverageBracket) {
    clear_response_type();
    set_has_resqueryleveragebracket();
    _impl_.response_type_.resqueryleveragebracket_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::ResQueryLeverageBracket*>(_impl_.response_type_.resqueryleveragebracket_);
}
inline ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* PROTOBUF_NONNULL Response::mutable_resqueryleveragebracket()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::ResQueryLeverageBracket* _msg = _internal_mutable_resqueryleveragebracket();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.resQueryLeverageBracket)
  return _msg;
}

// .lampyris.crypto.protocol.trading.SymbolLeverageBracketBean symbolLeverageBracketBean = 41;
inline bool Response::has_symbolleveragebracketbean() const {
  return response_type_case() == kSymbolLeverageBracketBean;
}
inline bool Response::_internal_has_symbolleveragebracketbean() const {
  return response_type_case() == kSymbolLeverageBracketBean;
}
inline void Response::set_has_symbolleveragebracketbean() {
  _impl_._oneof_case_[0] = kSymbolLeverageBracketBean;
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE Response::release_symbolleveragebracketbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  if (response_type_case() == kSymbolLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean*>(_impl_.response_type_.symbolleveragebracketbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.symbolleveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& Response::_internal_symbolleveragebracketbean() const {
  return response_type_case() == kSymbolLeverageBracketBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean*>(_impl_.response_type_.symbolleveragebracketbean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean&>(::lampyris::crypto::protocol::trading::_SymbolLeverageBracketBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean& Response::symbolleveragebracketbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  return _internal_symbolleveragebracketbean();
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_symbolleveragebracketbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  if (response_type_case() == kSymbolLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean*>(_impl_.response_type_.symbolleveragebracketbean_);
    _impl_.response_type_.symbolleveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_symbolleveragebracketbean(
    ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_symbolleveragebracketbean();
    _impl_.response_type_.symbolleveragebracketbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NONNULL Response::_internal_mutable_symbolleveragebracketbean() {
  if (response_type_case() != kSymbolLeverageBracketBean) {
    clear_response_type();
    set_has_symbolleveragebracketbean();
    _impl_.response_type_.symbolleveragebracketbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean*>(_impl_.response_type_.symbolleveragebracketbean_);
}
inline ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* PROTOBUF_NONNULL Response::mutable_symbolleveragebracketbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::SymbolLeverageBracketBean* _msg = _internal_mutable_symbolleveragebracketbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.symbolLeverageBracketBean)
  return _msg;
}

// .lampyris.crypto.protocol.trading.LeverageBracketBean leverageBracketBean = 42;
inline bool Response::has_leveragebracketbean() const {
  return response_type_case() == kLeverageBracketBean;
}
inline bool Response::_internal_has_leveragebracketbean() const {
  return response_type_case() == kLeverageBracketBean;
}
inline void Response::set_has_leveragebracketbean() {
  _impl_._oneof_case_[0] = kLeverageBracketBean;
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE Response::release_leveragebracketbean() {
  // @@protoc_insertion_point(field_release:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  if (response_type_case() == kLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBracketBean*>(_impl_.response_type_.leveragebracketbean_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.leveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::lampyris::crypto::protocol::trading::LeverageBracketBean& Response::_internal_leveragebracketbean() const {
  return response_type_case() == kLeverageBracketBean ? *reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBracketBean*>(_impl_.response_type_.leveragebracketbean_) : reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBracketBean&>(::lampyris::crypto::protocol::trading::_LeverageBracketBean_default_instance_);
}
inline const ::lampyris::crypto::protocol::trading::LeverageBracketBean& Response::leveragebracketbean() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  return _internal_leveragebracketbean();
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE Response::unsafe_arena_release_leveragebracketbean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  if (response_type_case() == kLeverageBracketBean) {
    clear_has_response_type();
    auto* temp = reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBracketBean*>(_impl_.response_type_.leveragebracketbean_);
    _impl_.response_type_.leveragebracketbean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_leveragebracketbean(
    ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response_type();
  if (value) {
    set_has_leveragebracketbean();
    _impl_.response_type_.leveragebracketbean_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lampyris.crypto.protocol.common.Response.leverageBracketBean)
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NONNULL Response::_internal_mutable_leveragebracketbean() {
  if (response_type_case() != kLeverageBracketBean) {
    clear_response_type();
    set_has_leveragebracketbean();
    _impl_.response_type_.leveragebracketbean_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::lampyris::crypto::protocol::trading::LeverageBracketBean>(GetArena()));
  }
  return reinterpret_cast<::lampyris::crypto::protocol::trading::LeverageBracketBean*>(_impl_.response_type_.leveragebracketbean_);
}
inline ::lampyris::crypto::protocol::trading::LeverageBracketBean* PROTOBUF_NONNULL Response::mutable_leveragebracketbean()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::lampyris::crypto::protocol::trading::LeverageBracketBean* _msg = _internal_mutable_leveragebracketbean();
  // @@protoc_insertion_point(field_mutable:lampyris.crypto.protocol.common.Response.leverageBracketBean)
  return _msg;
}

inline bool Response::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void Response::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::response_type_case() const {
  return Response::ResponseTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace protocol
}  // namespace crypto
}  // namespace lampyris


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // common_2eproto_2epb_2eh
